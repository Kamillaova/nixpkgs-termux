diff -Narupa a/dirent/bug-readdir1.c b/dirent/bug-readdir1.c
--- a/dirent/bug-readdir1.c
+++ b/dirent/bug-readdir1.c
@@ -14,7 +14,7 @@ main (void)
   struct dirent* ent;
 
   /* open a dir stream */
-  dirp = opendir ("/tmp");
+  dirp = opendir ("/data/data/com.termux/files/usr/tmp");
   if (dirp == NULL)
     {
       if (errno == ENOENT)
diff -Narupa a/elf/dl-load.c b/elf/dl-load.c
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -1330,15 +1330,15 @@ _dl_map_object_from_fd (const char *name
 		  errstring = N_("cannot change memory protections");
 		  goto lose_errno;
 		}
-	      __stack_prot |= PROT_READ|PROT_WRITE|PROT_EXEC;
+	      __stack_prot |= PROT_READ|PROT_WRITE;
 	      __mprotect ((void *) p, s, PROT_READ);
 	    }
 	  else
-	    __stack_prot |= PROT_READ|PROT_WRITE|PROT_EXEC;
+	    __stack_prot |= PROT_READ|PROT_WRITE;
 	}
       else
 #endif
-	__stack_prot |= PROT_READ|PROT_WRITE|PROT_EXEC;
+	__stack_prot |= PROT_READ|PROT_WRITE;
 
 #ifdef check_consistency
       check_consistency ();
diff -Narupa a/elf/rtld.c b/elf/rtld.c
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -360,7 +360,7 @@ struct rtld_global_ro _rtld_global_ro at
     ._dl_fpu_control = _FPU_DEFAULT,
     ._dl_pagesize = EXEC_PAGESIZE,
     ._dl_inhibit_cache = 0,
-    ._dl_profile_output = "/var/tmp",
+    ._dl_profile_output = "/data/data/com.termux/files/usr/var/tmp",
 
     /* Function pointers.  */
     ._dl_debug_printf = _dl_debug_printf,
@@ -1859,7 +1859,7 @@ dl_main (const ElfW(Phdr) *phdr,
      open().  So we do this first.  If it succeeds we do almost twice
      the work but this does not matter, since it is not for production
      use.  */
-  static const char preload_file[] = "/etc/ld.so.preload";
+  static const char preload_file[] = "/data/data/com.termux/files/usr/etc/ld.so.preload";
   if (__glibc_unlikely (__access (preload_file, R_OK) == 0))
     {
       /* Read the contents of the file.  */
diff -Narupa a/elf/sprof.c b/elf/sprof.c
--- a/elf/sprof.c
+++ b/elf/sprof.c
@@ -618,7 +618,7 @@ load_shobj (const char *name)
       *++cp = '\0';
 
       /* First add the debuginfo file name only.  */
-      static const char usrlibdebug[]= "/usr/lib/debug/";
+      static const char usrlibdebug[]= "/data/data/com.termux/files/usr/lib/debug/";
       char *workbuf = (char *) alloca (sizeof (usrlibdebug)
 				       + (cp - realname)
 				       + strlen (debuginfo_fname));
@@ -768,8 +768,8 @@ load_profdata (const char *name, struct
       /* A file with the given name does not exist in the current
 	 directory, try it in the default location where the profiling
 	 files are created.  */
-      ext_name = (char *) alloca (strlen (name) + sizeof "/var/tmp/");
-      stpcpy (stpcpy (ext_name, "/var/tmp/"), name);
+      ext_name = (char *) alloca (strlen (name) + sizeof "/data/data/com.termux/files/usr/var/tmp/");
+      stpcpy (stpcpy (ext_name, "/data/data/com.termux/files/usr/var/tmp/"), name);
       name = ext_name;
 
       fd = open (ext_name, O_RDONLY);
diff -Narupa a/include/shm-directory.h b/include/shm-directory.h
--- a/include/shm-directory.h
+++ b/include/shm-directory.h
@@ -23,7 +23,7 @@
 #include <stdbool.h>
 
 /* The directory that contains shared POSIX objects.  */
-#define SHMDIR _PATH_DEV "shm/"
+#define SHMDIR "/data/data/com.termux/files/usr/tmp/"
 
 struct shmdir_name
 {
diff -Narupa a/io/bug-ftw3.c b/io/bug-ftw3.c
--- a/io/bug-ftw3.c
+++ b/io/bug-ftw3.c
@@ -18,8 +18,8 @@ cb (const char *fname, const struct stat
 int
 main (void)
 {
-  char tmp[] = "/tmp/ftwXXXXXX";
-  char tmp2[] = "/tmp/ftwXXXXXX/ftwXXXXXX";
+  char tmp[] = "/data/data/com.termux/files/usr/tmp/ftwXXXXXX";
+  char tmp2[] = "/data/data/com.termux/files/usr/tmp/ftwXXXXXX/ftwXXXXXX";
   char *dname;
   char *dname2;
   int r;
diff -Narupa a/io/bug-ftw4.c b/io/bug-ftw4.c
--- a/io/bug-ftw4.c
+++ b/io/bug-ftw4.c
@@ -35,7 +35,7 @@ cb (const char *name, const struct stat6
 int
 main (void)
 {
-  char name[32] = "/tmp/ftwXXXXXX", *p;
+  char name[32] = "/data/data/com.termux/files/usr/tmp/ftwXXXXXX", *p;
   int ret, i, result = 0, fd, fd1, fd2;
 
   if (mkdtemp (name) == NULL)
diff -Narupa a/libio/oldiopopen.c b/libio/oldiopopen.c
--- a/libio/oldiopopen.c
+++ b/libio/oldiopopen.c
@@ -106,7 +106,7 @@ _IO_old_proc_open (FILE *fp, const char
       for (p = old_proc_file_chain; p; p = p->next)
 	__close (_IO_fileno ((FILE *) p));
 
-      execl ("/bin/sh", "sh", "-c", command, (char *) 0);
+      execl ("/data/data/com.termux/files/usr/bin/sh", "sh", "-c", command, (char *) 0);
       _exit (127);
     }
   __close (child_end);
diff -Narupa a/libio/stdio.h b/libio/stdio.h
--- a/libio/stdio.h
+++ b/libio/stdio.h
@@ -118,7 +118,7 @@ typedef __fpos64_t fpos64_t;
 
 #if defined __USE_MISC || defined __USE_XOPEN
 /* Default path prefix for `tempnam' and `tmpnam'.  */
-# define P_tmpdir	"/tmp"
+# define P_tmpdir	"/data/data/com.termux/files/usr/tmp"
 #endif
 
 #define L_tmpnam 20
diff -Narupa a/manual/examples/filecli.c b/manual/examples/filecli.c
--- a/manual/examples/filecli.c
+++ b/manual/examples/filecli.c
@@ -22,8 +22,8 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
-#define SERVER	"/tmp/serversocket"
-#define CLIENT	"/tmp/mysocket"
+#define SERVER	"/data/data/com.termux/files/usr/tmp/serversocket"
+#define CLIENT	"/data/data/com.termux/files/usr/tmp/mysocket"
 #define MAXMSG	512
 #define MESSAGE	"Yow!!! Are we having fun yet?!?"
 
diff -Narupa a/manual/examples/filesrv.c b/manual/examples/filesrv.c
--- a/manual/examples/filesrv.c
+++ b/manual/examples/filesrv.c
@@ -21,7 +21,7 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
-#define SERVER	"/tmp/serversocket"
+#define SERVER	"/data/data/com.termux/files/usr/tmp/serversocket"
 #define MAXMSG	512
 
 int
diff -Narupa a/manual/examples/ofdlocks.c b/manual/examples/ofdlocks.c
--- a/manual/examples/ofdlocks.c
+++ b/manual/examples/ofdlocks.c
@@ -23,7 +23,7 @@
 #include <fcntl.h>
 #include <pthread.h>
 
-#define FILENAME	"/tmp/foo"
+#define FILENAME	"/data/data/com.termux/files/usr/tmp/foo"
 #define NUM_THREADS	3
 #define ITERATIONS	5
 
@@ -39,7 +39,7 @@ thread_start (void *arg)
     .l_len = 1,
   };
 
-  fd = open ("/tmp/foo", O_RDWR | O_CREAT, 0666);
+  fd = open ("/data/data/com.termux/files/usr/tmp/foo", O_RDWR | O_CREAT, 0666);
 
   for (i = 0; i < ITERATIONS; i++)
     {
diff -Narupa a/misc/Makefile b/misc/Makefile
--- a/misc/Makefile
+++ b/misc/Makefile
@@ -192,6 +192,7 @@ routines := \
   swapon \
   sync \
   syncfs \
+  syscallS \
   syscall \
   syslog \
   truncate \
diff -Narupa a/misc/Versions b/misc/Versions
--- a/misc/Versions
+++ b/misc/Versions
@@ -71,7 +71,7 @@ libc {
     # s*
     sbrk; select; setdomainname; setfsent; sethostent; sethostid; sethostname;
     setlogmask; setmntent; setregid; setreuid; setttyent; setusershell; sstk;
-    stty; sync; syscall; syslog;
+    stty; sync; syscallS; syscall; syslog;
 
     # t*
     tdelete; tfind; truncate; tsearch; ttyslot; twalk;
diff -Narupa a/nis/ypclnt.c b/nis/ypclnt.c
--- a/nis/ypclnt.c
+++ b/nis/ypclnt.c
@@ -33,7 +33,7 @@
 
 /* This should only be defined on systems with a BSD compatible ypbind */
 #ifndef BINDINGDIR
-# define BINDINGDIR "/var/yp/binding"
+# define BINDINGDIR "/data/data/com.termux/files/usr/var/yp/binding"
 #endif
 
 struct dom_binding
diff -Narupa a/nptl/pthread_create.c b/nptl/pthread_create.c
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -379,16 +379,6 @@ start_thread (void *arg)
       __libc_fatal ("Fatal glibc error: rseq registration failed\n");
   }
 
-#ifndef __ASSUME_SET_ROBUST_LIST
-  if (__nptl_set_robust_list_avail)
-#endif
-    {
-      /* This call should never fail because the initial call in init.c
-	 succeeded.  */
-      INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-			     sizeof (struct robust_list_head));
-    }
-
   /* This is where the try/finally block should be created.  For
      compilers without that support we do use setjmp.  */
   struct pthread_unwind_buf unwind_buf;
diff -Narupa a/nscd/getgrgid_r.c b/nscd/getgrgid_r.c
--- a/nscd/getgrgid_r.c
+++ b/nscd/getgrgid_r.c
@@ -27,6 +27,7 @@
 
 #define DEEPCOPY_FN	__copy_grp
 #define MERGE_FN	__merge_grp
+#define ANDROID_SYS	getgrgid_android
 
 /* We are nscd, so we don't want to be talking to ourselves.  */
 #undef	USE_NSCD
diff -Narupa a/nscd/getgrnam_r.c b/nscd/getgrnam_r.c
--- a/nscd/getgrnam_r.c
+++ b/nscd/getgrnam_r.c
@@ -23,6 +23,7 @@
 #define DATABASE_NAME	group
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
+#define ANDROID_SYS	getgrnam_android
 
 #define DEEPCOPY_FN	__copy_grp
 #define MERGE_FN	__merge_grp
diff -Narupa a/nscd/getpwnam_r.c b/nscd/getpwnam_r.c
--- a/nscd/getpwnam_r.c
+++ b/nscd/getpwnam_r.c
@@ -23,6 +23,7 @@
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwnam_android
 
 /* We are nscd, so we don't want to be talking to ourselves.  */
 #undef	USE_NSCD
diff -Narupa a/nscd/getpwuid_r.c b/nscd/getpwuid_r.c
--- a/nscd/getpwuid_r.c
+++ b/nscd/getpwuid_r.c
@@ -23,6 +23,7 @@
 #define ADD_PARAMS	uid_t uid
 #define ADD_VARIABLES	uid
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwuid_android
 
 /* We are nscd, so we don't want to be talking to ourselves.  */
 #undef	USE_NSCD
diff -Narupa a/nscd/nscd-client.h b/nscd/nscd-client.h
--- a/nscd/nscd-client.h
+++ b/nscd/nscd-client.h
@@ -35,13 +35,13 @@
 #define NSCD_VERSION 2
 
 /* Path of the file where the PID of the running system is stored.  */
-#define _PATH_NSCDPID	 "/var/run/nscd/nscd.pid"
+#define _PATH_NSCDPID	 "/data/data/com.termux/files/usr/var/run/nscd/nscd.pid"
 
 /* Path for the Unix domain socket.  */
-#define _PATH_NSCDSOCKET "/var/run/nscd/socket"
+#define _PATH_NSCDSOCKET "/data/data/com.termux/files/usr/var/run/nscd/socket"
 
 /* Path for the configuration file.  */
-#define _PATH_NSCDCONF	 "/etc/nscd.conf"
+#define _PATH_NSCDCONF	 "/data/data/com.termux/files/usr/etc/nscd.conf"
 
 /* Maximum allowed length for the key.  */
 #define MAXKEYLEN 1024
diff -Narupa a/nss/android_ids.h b/nss/android_ids.h
--- a/nss/android_ids.h
+++ b/nss/android_ids.h
@@ -0,0 +1,173 @@
+#ifndef _ANDROID_IDS
+#define _ANDROID_IDS
+
+#include "android_system_user_ids.h"
+
+#define AID_USER_OFFSET 100000
+#define AID_OVERFLOWUID 65534
+#define AID_ISOLATED_START 99000
+#define AID_ISOLATED_END 99999
+#define AID_APP_START 10000
+#define AID_APP_END 19999
+#define AID_CACHE_GID_START 20000
+#define AID_CACHE_GID_END 29999
+#define AID_EXT_GID_START 30000
+#define AID_EXT_GID_END 39999
+#define AID_EXT_CACHE_GID_START 40000
+#define AID_EXT_CACHE_GID_END 49999
+#define AID_SHARED_GID_START 50000
+#define AID_SHARED_GID_END 59999
+
+#define AID_OEM_RESERVED_START 2900
+#define AID_OEM_RESERVED_END 2999
+#define AID_OEM_RESERVED_2_START 5000
+#define AID_OEM_RESERVED_2_END 5999
+
+struct IdRange {
+    id_t start;
+    id_t end;
+};
+
+static struct IdRange user_ranges[] = {
+    { AID_APP_START, AID_APP_END },
+    { AID_ISOLATED_START, AID_ISOLATED_END },
+};
+
+static struct IdRange group_ranges[] = {
+    { AID_APP_START, AID_APP_END },
+    { AID_CACHE_GID_START, AID_CACHE_GID_END },
+    { AID_EXT_GID_START, AID_EXT_GID_END },
+    { AID_EXT_CACHE_GID_START, AID_EXT_CACHE_GID_END },
+    { AID_SHARED_GID_START, AID_SHARED_GID_END },
+    { AID_ISOLATED_START, AID_ISOLATED_END },
+};
+
+struct android_id_info {
+    const char *name;
+    unsigned aid;
+};
+
+static struct android_id_info android_ids[] = {
+    { "root", AID_ROOT, },
+    { "daemon", AID_DAEMON, },
+    { "bin", AID_BIN, },
+    { "sys", AID_SYS, },
+    { "system", AID_SYSTEM, },
+    { "radio", AID_RADIO, },
+    { "bluetooth", AID_BLUETOOTH, },
+    { "graphics", AID_GRAPHICS, },
+    { "input", AID_INPUT, },
+    { "audio", AID_AUDIO, },
+    { "camera", AID_CAMERA, },
+    { "log", AID_LOG, },
+    { "compass", AID_COMPASS, },
+    { "mount", AID_MOUNT, },
+    { "wifi", AID_WIFI, },
+    { "adb", AID_ADB, },
+    { "install", AID_INSTALL, },
+    { "media", AID_MEDIA, },
+    { "dhcp", AID_DHCP, },
+    { "sdcard_rw", AID_SDCARD_RW, },
+    { "vpn", AID_VPN, },
+    { "keystore", AID_KEYSTORE, },
+    { "usb", AID_USB, },
+    { "drm", AID_DRM, },
+    { "mdnsr", AID_MDNSR, },
+    { "gps", AID_GPS, },
+    { "unused1", AID_UNUSED1, },
+    { "media_rw", AID_MEDIA_RW, },
+    { "mtp", AID_MTP, },
+    { "unused2", AID_UNUSED2, },
+    { "drmrpc", AID_DRMRPC, },
+    { "nfc", AID_NFC, },
+    { "sdcard_r", AID_SDCARD_R, },
+    { "clat", AID_CLAT, },
+    { "loop_radio", AID_LOOP_RADIO, },
+    { "media_drm", AID_MEDIA_DRM, },
+    { "package_info", AID_PACKAGE_INFO, },
+    { "sdcard_pics", AID_SDCARD_PICS, },
+    { "sdcard_av", AID_SDCARD_AV, },
+    { "sdcard_all", AID_SDCARD_ALL, },
+    { "logd", AID_LOGD, },
+    { "shared_relro", AID_SHARED_RELRO, },
+    { "dbus", AID_DBUS, },
+    { "tlsdate", AID_TLSDATE, },
+    { "media_ex", AID_MEDIA_EX, },
+    { "audioserver", AID_AUDIOSERVER, },
+    { "metrics_coll", AID_METRICS_COLL, },
+    { "metricsd", AID_METRICSD, },
+    { "webserv", AID_WEBSERV, },
+    { "debuggerd", AID_DEBUGGERD, },
+    { "media_codec", AID_MEDIA_CODEC, },
+    { "cameraserver", AID_CAMERASERVER, },
+    { "firewall", AID_FIREWALL, },
+    { "trunks", AID_TRUNKS, },
+    { "nvram", AID_NVRAM, },
+    { "dns", AID_DNS, },
+    { "dns_tether", AID_DNS_TETHER, },
+    { "webview_zygote", AID_WEBVIEW_ZYGOTE, },
+    { "vehicle_network", AID_VEHICLE_NETWORK, },
+    { "media_audio", AID_MEDIA_AUDIO, },
+    { "media_video", AID_MEDIA_VIDEO, },
+    { "media_image", AID_MEDIA_IMAGE, },
+    { "tombstoned", AID_TOMBSTONED, },
+    { "media_obb", AID_MEDIA_OBB, },
+    { "ese", AID_ESE, },
+    { "ota_update", AID_OTA_UPDATE, },
+    { "automotive_evs", AID_AUTOMOTIVE_EVS, },
+    { "lowpan", AID_LOWPAN, },
+    { "hsm", AID_HSM, },
+    { "reserved_disk", AID_RESERVED_DISK, },
+    { "statsd", AID_STATSD, },
+    { "incidentd", AID_INCIDENTD, },
+    { "secure_element", AID_SECURE_ELEMENT, },
+    { "lmkd", AID_LMKD, },
+    { "llkd", AID_LLKD, },
+    { "iorapd", AID_IORAPD, },
+    { "gpu_service", AID_GPU_SERVICE, },
+    { "network_stack", AID_NETWORK_STACK, },
+    { "gsid", AID_GSID, },
+    { "fsverity_cert", AID_FSVERITY_CERT, },
+    { "credstore", AID_CREDSTORE, },
+    { "external_storage", AID_EXTERNAL_STORAGE, },
+    { "ext_data_rw", AID_EXT_DATA_RW, },
+    { "ext_obb_rw", AID_EXT_OBB_RW, },
+    { "context_hub", AID_CONTEXT_HUB, },
+    { "virtualizationservice", AID_VIRTUALIZATIONSERVICE, },
+    { "artd", AID_ARTD, },
+    { "uwb", AID_UWB, },
+    { "thread_network", AID_THREAD_NETWORK, },
+    { "diced", AID_DICED, },
+    { "dmesgd", AID_DMESGD, },
+    { "jc_weaver", AID_JC_WEAVER, },
+    { "jc_strongbox", AID_JC_STRONGBOX, },
+    { "jc_identitycred", AID_JC_IDENTITYCRED, },
+    { "sdk_sandbox", AID_SDK_SANDBOX, },
+    { "security_log_writer", AID_SECURITY_LOG_WRITER, },
+    { "prng_seeder", AID_PRNG_SEEDER, },
+    { "shell", AID_SHELL, },
+    { "cache", AID_CACHE, },
+    { "diag", AID_DIAG, },
+    { "net_bt_admin", AID_NET_BT_ADMIN, },
+    { "net_bt", AID_NET_BT, },
+    { "inet", AID_INET, },
+    { "net_raw", AID_NET_RAW, },
+    { "net_admin", AID_NET_ADMIN, },
+    { "net_bw_stats", AID_NET_BW_STATS, },
+    { "net_bw_acct", AID_NET_BW_ACCT, },
+    { "readproc", AID_READPROC, },
+    { "wakelock", AID_WAKELOCK, },
+    { "uhid", AID_UHID, },
+    { "readtracefs", AID_READTRACEFS, },
+    { "everybody", AID_EVERYBODY, },
+    { "misc", AID_MISC, },
+    { "nobody", AID_NOBODY, },
+};
+
+#define android_id_count (sizeof(android_ids) / sizeof(android_ids[0]))
+
+// default paths for the application
+#define APP_HOME_DIR "/data/data/com.termux/files/home"
+#define APP_PREFIX_DIR "/data/data/com.termux/files/usr"
+
+#endif // _ANDROID_IDS
diff -Narupa a/nss/android_passwd_group.c b/nss/android_passwd_group.c
--- a/nss/android_passwd_group.c
+++ b/nss/android_passwd_group.c
@@ -0,0 +1,284 @@
+/* This script stores functions similar to those from
+   the bionic library, thanks to which passwd/group
+   structures are created.
+*/
+
+#ifndef _ANDROID_PASSWD_GROUP
+#define _ANDROID_PASSWD_GROUP
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "android_passwd_group.h"
+
+struct android_id_info * find_android_id_info_by_id(unsigned id) {
+	for (size_t n = 0; n < android_id_count; ++n)
+		if (android_ids[n].aid == id)
+			return &android_ids[n];
+	return NULL;
+}
+
+struct android_id_info * find_android_id_info_by_name(const char* name) {
+	for (size_t n = 0; n < android_id_count; ++n)
+		if (!strcmp(android_ids[n].name, name))
+			return &android_ids[n];
+	return NULL;
+}
+
+int is_oem_id_android(id_t id) {
+	if (id >= AID_OEM_RESERVED_START && id < AID_EVERYBODY && find_android_id_info_by_id(id) == NULL)
+		return 1;
+
+	return (id >= AID_OEM_RESERVED_START && id <= AID_OEM_RESERVED_END) ||
+		(id >= AID_OEM_RESERVED_2_START && id <= AID_OEM_RESERVED_2_END);
+}
+
+int is_valid_id_android(id_t id, int is_group) {
+	if (id >= AID_USER_OFFSET)
+		return 0;
+
+	struct IdRange * ranges;
+	size_t ranges_size;
+	id_t appid = id % AID_USER_OFFSET;
+
+	if (appid == AID_OVERFLOWUID)
+		return 0;
+
+	if (is_group) {
+		ranges_size = sizeof(group_ranges)/sizeof(group_ranges[0]);
+		ranges = group_ranges;
+	} else {
+		ranges_size = sizeof(user_ranges)/sizeof(user_ranges[0]);
+		ranges = user_ranges;
+	}
+
+	if (appid < ranges[0].start)
+		return 1;
+
+	if (appid >= AID_SHARED_GID_START && appid <= AID_SHARED_GID_END && appid != id)
+		return 0;
+
+	for (size_t i = 0; i < ranges_size; ++i)
+		if (appid >= ranges[i].start && appid <= ranges[i].end)
+			return 1;
+
+	return 0;
+}
+
+static id_t oem_id_from_name_android(const char* name) {
+	unsigned int id;
+	if (sscanf(name, "oem_%u", &id) != 1) {
+		return 0;
+	}
+	if (!is_oem_id_android(id)) {
+		return 0;
+	}
+	return (id_t)id;
+}
+
+static id_t app_id_from_name_android(const char* name, int is_group) {
+	char* end;
+	unsigned long userid;
+	struct android_id_info* info;
+	int is_shared_gid = 0;
+
+	if (is_group && name[0] == 'a' && name[1] == 'l' && name[2] == 'l') {
+		end = malloc(strlen(name));
+		for (int i=3; i<strlen(name); i++)
+			sprintf(end, "%s%c", end, name[i]);
+		userid = 0;
+		is_shared_gid = 1;
+	} else if (name[0] == 'u' && isdigit(name[1])) {
+		userid = strtoul(name+1, &end, 10);
+	} else {
+		return 0;
+	}
+
+	if (end[0] != '_' || end[1] == 0) {
+		return 0;
+	}
+
+	unsigned long appid = 0;
+	if (end[1] == 'a' && isdigit(end[2])) {
+		if (is_shared_gid) {
+			appid = strtoul(end+2, &end, 10) + AID_SHARED_GID_START;
+			if (appid > AID_SHARED_GID_END) {
+				return 0;
+			}
+		} else {
+			appid = strtoul(end+2, &end, 10);
+			if (is_group) {
+				if (!strcmp(end, "_ext_cache")) {
+					end += 10;
+					appid += AID_EXT_CACHE_GID_START;
+				} else if (!strcmp(end, "_ext")) {
+					end += 4;
+					appid += AID_EXT_GID_START;
+				} else if (!strcmp(end, "_cache")) {
+					end += 6;
+					appid += AID_CACHE_GID_START;
+				} else {
+					appid += AID_APP_START;
+				}
+			} else {
+				appid += AID_APP_START;
+			}
+		}
+	} else if (end[1] == 'i' && isdigit(end[2])) {
+		appid = strtoul(end+2, &end, 10) + AID_ISOLATED_START;
+	} else if ((info = find_android_id_info_by_name(end + 1)) != NULL) {
+		appid = info->aid;
+		end += strlen(info->name) + 1;
+	}
+
+	if (end[0] != 0) {
+		return 0;
+	}
+
+	if (userid > 1000) {
+		return 0;
+	}
+
+	if (appid >= AID_USER_OFFSET) {
+		return 0;
+	}
+
+	return (appid + userid*AID_USER_OFFSET);
+}
+
+void get_name_by_uid_android(uid_t uid, char *name_u) {
+	uid_t appid = uid % AID_USER_OFFSET;
+	uid_t userid = uid / AID_USER_OFFSET;
+	struct android_id_info* info;
+
+	if (appid >= AID_ISOLATED_START) {
+		sprintf(name_u, "u%u_i%u", userid, appid - AID_ISOLATED_START);
+	} else if (appid < AID_APP_START) {
+		if ((info = find_android_id_info_by_id(appid)) != NULL)
+			sprintf(name_u, "%s", info->name);
+	} else {
+		sprintf(name_u, "u%u_a%u", userid, appid - AID_APP_START);
+	}
+}
+
+void get_name_by_gid_android(gid_t gid, char *name_g) {
+	uid_t appid = gid % AID_USER_OFFSET;
+	uid_t userid = gid / AID_USER_OFFSET;
+	struct android_id_info* info;
+
+	if (appid >= AID_ISOLATED_START) {
+		sprintf(name_g, "u%u_i%u", userid, appid - AID_ISOLATED_START);
+	} else if (userid == 0 && appid >= AID_SHARED_GID_START && appid <= AID_SHARED_GID_END) {
+		sprintf(name_g, "all_a%u", appid - AID_SHARED_GID_START);
+	} else if (appid >= AID_EXT_CACHE_GID_START && appid <= AID_EXT_CACHE_GID_END) {
+		sprintf(name_g, "u%u_a%u_ext_cache", userid, appid - AID_EXT_CACHE_GID_START);
+	} else if (appid >= AID_EXT_GID_START && appid <= AID_EXT_GID_END) {
+		sprintf(name_g, "u%u_a%u_ext", userid, appid - AID_EXT_GID_START);
+	} else if (appid >= AID_CACHE_GID_START && appid <= AID_CACHE_GID_END) {
+		sprintf(name_g, "u%u_a%u_cache", userid, appid - AID_CACHE_GID_START);
+	} else if (appid < AID_APP_START) {
+		if ((info = find_android_id_info_by_id(appid)) != NULL)
+			sprintf(name_g, "%s", info->name);
+	} else {
+		sprintf(name_g, "u%u_a%u", userid, appid - AID_APP_START);
+	}
+}
+
+struct passwd * get_passwd_android(char* name, uid_t uid) {
+	static struct passwd res;
+
+	res.pw_name = name;
+	res.pw_passwd = "*";
+	res.pw_uid = uid;
+	res.pw_gid = uid;
+	res.pw_gecos = "";
+	res.pw_dir = APP_HOME_DIR;
+	res.pw_shell = APP_PREFIX_DIR "/bin/login";
+
+	return &res;
+}
+
+struct group * get_group_android(char* name, gid_t gid) {
+	static struct group res;
+
+	res.gr_name = name;
+	res.gr_passwd = NULL;
+	res.gr_gid = gid;
+	res.gr_mem = (char *[2]){(char *)name, NULL};
+
+	return &res;
+}
+
+struct passwd * getpwuid_android(uid_t uid) {
+	char* name_res = malloc(64);
+
+	if (is_oem_id_android(uid))
+		sprintf(name_res, "oem_%u", uid);
+	else {
+		if (!is_valid_id_android(uid, 0))
+			return NULL;
+		get_name_by_uid_android(uid, name_res);
+		if (strlen(name_res) == 0)
+			return NULL;
+	}
+
+	return get_passwd_android(name_res, uid);
+}
+
+struct group * getgrgid_android(gid_t gid) {
+	char* name_res = malloc(64);
+
+	if (is_oem_id_android(gid))
+		sprintf(name_res, "oem_%u", gid);
+	else {
+		if (!is_valid_id_android(gid, 1))
+			return NULL;
+        	get_name_by_gid_android(gid, name_res);
+		if (strlen(name_res) == 0)
+			return NULL;
+	}
+
+	return get_group_android(name_res, gid);
+}
+
+struct passwd * getpwnam_android(char* name) {
+	uid_t uid;
+	struct android_id_info* info;
+
+	uid = app_id_from_name_android(name, 0);
+	if (uid != 0)
+		return get_passwd_android(name, uid);
+
+	uid = oem_id_from_name_android(name);
+	if (uid != 0)
+		return get_passwd_android(name, uid);
+
+	info = find_android_id_info_by_name(name);
+	if (info != NULL)
+		return get_passwd_android(name, info->aid);
+
+	return NULL;
+}
+
+struct group * getgrnam_android(char* name) {
+	gid_t gid;
+	struct android_id_info* info;
+
+	gid = app_id_from_name_android(name, 1);
+	if (gid != 0)
+		return get_group_android(name, gid);
+
+	gid = oem_id_from_name_android(name);
+	if (gid != 0)
+		return get_group_android(name, gid);
+
+	info = find_android_id_info_by_name(name);
+	if (info != NULL)
+		return get_group_android(name, info->aid);
+
+	return NULL;
+}
+
+#endif // _ANDROID_PASSWD_GROUP
diff -Narupa a/nss/android_passwd_group.h b/nss/android_passwd_group.h
--- a/nss/android_passwd_group.h
+++ b/nss/android_passwd_group.h
@@ -0,0 +1,23 @@
+#ifndef _ANDROID_PASSWD_GROUP_H
+#define _ANDROID_PASSWD_GROUP_H
+
+#include <pwd.h>
+#include <grp.h>
+#include "android_ids.h"
+
+struct android_id_info * find_android_id_info_by_id(unsigned id);
+struct android_id_info * find_android_id_info_by_name(const char* name);
+int is_oem_id_android(id_t id);
+int is_valid_id_android(id_t id, int is_group);
+static id_t oem_id_from_name_android(const char* name);
+static id_t app_id_from_name_android(const char* name, int is_group);
+void get_name_by_uid_android(uid_t uid, char *name_u);
+void get_name_by_gid_android(gid_t gid, char *name_g);
+struct passwd * get_passwd_android(char* name, uid_t uid);
+struct group * get_group_android(char* name, gid_t gid);
+struct passwd * getpwuid_android(uid_t uid);
+struct group * getgrgid_android(gid_t gid);
+struct passwd * getpwnam_android(char* name);
+struct group * getgrnam_android(char* name);
+
+#endif // _ANDROID_PASSWD_GROUP_H
diff -Narupa a/nss/android_system_user_ids.h b/nss/android_system_user_ids.h
--- a/nss/android_system_user_ids.h
+++ b/nss/android_system_user_ids.h
@@ -0,0 +1,114 @@
+#define AID_ROOT 0 /* traditional unix root user */
+#define AID_DAEMON 1 /* Traditional unix daemon owner. */
+#define AID_BIN 2    /* Traditional unix binaries owner. */
+#define AID_SYS 3    /* A group with the same gid on Linux/macOS/Android. */
+#define AID_SYSTEM 1000 /* system server */
+#define AID_RADIO 1001           /* telephony subsystem, RIL */
+#define AID_BLUETOOTH 1002       /* bluetooth subsystem */
+#define AID_GRAPHICS 1003        /* graphics devices */
+#define AID_INPUT 1004           /* input devices */
+#define AID_AUDIO 1005           /* audio devices */
+#define AID_CAMERA 1006          /* camera devices */
+#define AID_LOG 1007             /* log devices */
+#define AID_COMPASS 1008         /* compass device */
+#define AID_MOUNT 1009           /* mountd socket */
+#define AID_WIFI 1010            /* wifi subsystem */
+#define AID_ADB 1011             /* android debug bridge (adbd) */
+#define AID_INSTALL 1012         /* group for installing packages */
+#define AID_MEDIA 1013           /* mediaserver process */
+#define AID_DHCP 1014            /* dhcp client */
+#define AID_SDCARD_RW 1015       /* external storage write access */
+#define AID_VPN 1016             /* vpn system */
+#define AID_KEYSTORE 1017        /* keystore subsystem */
+#define AID_USB 1018             /* USB devices */
+#define AID_DRM 1019             /* DRM server */
+#define AID_MDNSR 1020           /* MulticastDNSResponder (service discovery) */
+#define AID_GPS 1021             /* GPS daemon */
+#define AID_UNUSED1 1022         /* deprecated, DO NOT USE */
+#define AID_MEDIA_RW 1023        /* internal media storage write access */
+#define AID_MTP 1024             /* MTP USB driver access */
+#define AID_UNUSED2 1025         /* deprecated, DO NOT USE */
+#define AID_DRMRPC 1026          /* group for drm rpc */
+#define AID_NFC 1027             /* nfc subsystem */
+#define AID_SDCARD_R 1028        /* external storage read access */
+#define AID_CLAT 1029            /* clat part of nat464 */
+#define AID_LOOP_RADIO 1030      /* loop radio devices */
+#define AID_MEDIA_DRM 1031       /* MediaDrm plugins */
+#define AID_PACKAGE_INFO 1032    /* access to installed package details */
+#define AID_SDCARD_PICS 1033     /* external storage photos access */
+#define AID_SDCARD_AV 1034       /* external storage audio/video access */
+#define AID_SDCARD_ALL 1035      /* access all users external storage */
+#define AID_LOGD 1036            /* log daemon */
+#define AID_SHARED_RELRO 1037    /* creator of shared GNU RELRO files */
+#define AID_DBUS 1038            /* dbus-daemon IPC broker process */
+#define AID_TLSDATE 1039         /* tlsdate unprivileged user */
+#define AID_MEDIA_EX 1040        /* mediaextractor process */
+#define AID_AUDIOSERVER 1041     /* audioserver process */
+#define AID_METRICS_COLL 1042    /* metrics_collector process */
+#define AID_METRICSD 1043        /* metricsd process */
+#define AID_WEBSERV 1044         /* webservd process */
+#define AID_DEBUGGERD 1045       /* debuggerd unprivileged user */
+#define AID_MEDIA_CODEC 1046     /* mediacodec process */
+#define AID_CAMERASERVER 1047    /* cameraserver process */
+#define AID_FIREWALL 1048        /* firewalld process */
+#define AID_TRUNKS 1049          /* trunksd process (TPM daemon) */
+#define AID_NVRAM 1050           /* Access-controlled NVRAM */
+#define AID_DNS 1051             /* DNS resolution daemon (system: netd) */
+#define AID_DNS_TETHER 1052      /* DNS resolution daemon (tether: dnsmasq) */
+#define AID_WEBVIEW_ZYGOTE 1053  /* WebView zygote process */
+#define AID_VEHICLE_NETWORK 1054 /* Vehicle network service */
+#define AID_MEDIA_AUDIO 1055     /* GID for audio files on internal media storage */
+#define AID_MEDIA_VIDEO 1056     /* GID for video files on internal media storage */
+#define AID_MEDIA_IMAGE 1057     /* GID for image files on internal media storage */
+#define AID_TOMBSTONED 1058      /* tombstoned user */
+#define AID_MEDIA_OBB 1059       /* GID for OBB files on internal media storage */
+#define AID_ESE 1060             /* embedded secure element (eSE) subsystem */
+#define AID_OTA_UPDATE 1061      /* resource tracking UID for OTA updates */
+#define AID_AUTOMOTIVE_EVS 1062  /* Automotive rear and surround view system */
+#define AID_LOWPAN 1063          /* LoWPAN subsystem */
+#define AID_HSM 1064             /* hardware security module subsystem */
+#define AID_RESERVED_DISK 1065   /* GID that has access to reserved disk space */
+#define AID_STATSD 1066          /* statsd daemon */
+#define AID_INCIDENTD 1067       /* incidentd daemon */
+#define AID_SECURE_ELEMENT 1068  /* secure element subsystem */
+#define AID_LMKD 1069            /* low memory killer daemon */
+#define AID_LLKD 1070            /* live lock daemon */
+#define AID_IORAPD 1071          /* input/output readahead and pin daemon */
+#define AID_GPU_SERVICE 1072     /* GPU service daemon */
+#define AID_NETWORK_STACK 1073   /* network stack service */
+#define AID_GSID 1074            /* GSI service daemon */
+#define AID_FSVERITY_CERT 1075   /* fs-verity key ownership in keystore */
+#define AID_CREDSTORE 1076       /* identity credential manager service */
+#define AID_EXTERNAL_STORAGE 1077 /* Full external storage access including USB OTG volumes */
+#define AID_EXT_DATA_RW 1078      /* GID for app-private data directories on external storage */
+#define AID_EXT_OBB_RW 1079       /* GID for OBB directories on external storage */
+#define AID_CONTEXT_HUB 1080      /* GID for access to the Context Hub */
+#define AID_VIRTUALIZATIONSERVICE 1081 /* VirtualizationService daemon */
+#define AID_ARTD 1082             /* ART Service daemon */
+#define AID_UWB 1083              /* UWB subsystem */
+#define AID_THREAD_NETWORK 1084   /* Thread Network subsystem */
+#define AID_DICED 1085            /* Android's DICE daemon */
+#define AID_DMESGD 1086           /* dmesg parsing daemon for kernel report collection */
+#define AID_JC_WEAVER 1087        /* Javacard Weaver HAL - to manage omapi ARA rules */
+#define AID_JC_STRONGBOX 1088     /* Javacard Strongbox HAL - to manage omapi ARA rules */
+#define AID_JC_IDENTITYCRED 1089  /* Javacard Identity Cred HAL - to manage omapi ARA rules */
+#define AID_SDK_SANDBOX 1090      /* SDK sandbox virtual UID */
+#define AID_SECURITY_LOG_WRITER 1091 /* write to security log */
+#define AID_PRNG_SEEDER 1092         /* PRNG seeder daemon */
+#define AID_SHELL 2000 /* adb and debug shell user */
+#define AID_CACHE 2001 /* cache access */
+#define AID_DIAG 2002  /* access to diagnostic resources */
+#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */
+#define AID_NET_BT 3002       /* bluetooth: create sco, rfcomm or l2cap sockets */
+#define AID_INET 3003         /* can create AF_INET and AF_INET6 sockets */
+#define AID_NET_RAW 3004      /* can create raw INET sockets */
+#define AID_NET_ADMIN 3005    /* can configure interfaces and routing tables. */
+#define AID_NET_BW_STATS 3006 /* read bandwidth statistics */
+#define AID_NET_BW_ACCT 3007  /* change bandwidth statistics accounting */
+#define AID_READPROC 3009     /* Allow /proc read access */
+#define AID_WAKELOCK 3010     /* Allow system wakelock read/write access */
+#define AID_UHID 3011         /* Allow read/write to /dev/uhid node */
+#define AID_READTRACEFS 3012  /* Allow tracefs read */
+#define AID_EVERYBODY 9997 /* shared between all apps in the same profile */
+#define AID_MISC 9998      /* access to misc storage */
+#define AID_NOBODY 9999
diff -Narupa a/nss/db-Makefile b/nss/db-Makefile
--- a/nss/db-Makefile
+++ b/nss/db-Makefile
@@ -17,11 +17,11 @@
 # License along with the GNU C Library; if not, see
 # <https://www.gnu.org/licenses/>.
 
-DATABASES = $(wildcard /etc/passwd /etc/group /etc/ethers /etc/protocols \
-		       /etc/rpc /etc/services /etc/shadow /etc/gshadow \
-		       /etc/netgroup)
+DATABASES = $(wildcard /data/data/com.termux/files/usr/etc/passwd /data/data/com.termux/files/usr/etc/group /data/data/com.termux/files/usr/etc/ethers /data/data/com.termux/files/usr/etc/protocols \
+		       /data/data/com.termux/files/usr/etc/rpc /data/data/com.termux/files/usr/etc/services /data/data/com.termux/files/usr/etc/shadow /data/data/com.termux/files/usr/etc/gshadow \
+		       /data/data/com.termux/files/usr/etc/netgroup)
 
-VAR_DB = /var/db
+VAR_DB = /data/data/com.termux/files/usr/var/db
 
 AWK = awk
 MAKEDB = makedb --quiet
@@ -29,7 +29,7 @@ MAKEDB = makedb --quiet
 all: $(patsubst %,$(VAR_DB)/%.db,$(notdir $(DATABASES)))
 
 
-$(VAR_DB)/passwd.db: /etc/passwd
+$(VAR_DB)/passwd.db: /data/data/com.termux/files/usr/etc/passwd
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { FS=":"; OFS=":" } \
 		 /^[ \t]*$$/ { next } \
@@ -39,7 +39,7 @@ $(VAR_DB)/passwd.db: /etc/passwd
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/group.db: /etc/group
+$(VAR_DB)/group.db: /data/data/com.termux/files/usr/etc/group
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { FS=":"; OFS=":" } \
 		 /^[ \t]*$$/ { next } \
@@ -61,7 +61,7 @@ $(VAR_DB)/group.db: /etc/group
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/ethers.db: /etc/ethers
+$(VAR_DB)/ethers.db: /data/data/com.termux/files/usr/etc/ethers
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) '/^[ \t]*$$/ { next } \
 		 /^[ \t]*#/ { next } \
@@ -70,7 +70,7 @@ $(VAR_DB)/ethers.db: /etc/ethers
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/protocols.db: /etc/protocols
+$(VAR_DB)/protocols.db: /data/data/com.termux/files/usr/etc/protocols
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) '/^[ \t]*$$/ { next } \
 		 /^[ \t]*#/ { next } \
@@ -81,7 +81,7 @@ $(VAR_DB)/protocols.db: /etc/protocols
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/rpc.db: /etc/rpc
+$(VAR_DB)/rpc.db: /data/data/com.termux/files/usr/etc/rpc
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) '/^[ \t]*$$/ { next } \
 		 /^[ \t]*#/ { next } \
@@ -92,7 +92,7 @@ $(VAR_DB)/rpc.db: /etc/rpc
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/services.db: /etc/services
+$(VAR_DB)/services.db: /data/data/com.termux/files/usr/etc/services
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { FS="[ \t/]+" } \
 		 /^[ \t]*$$/ { next } \
@@ -108,7 +108,7 @@ $(VAR_DB)/services.db: /etc/services
 	$(MAKEDB) -o $@ -
 	@echo "done."
 
-$(VAR_DB)/shadow.db: /etc/shadow
+$(VAR_DB)/shadow.db: /data/data/com.termux/files/usr/etc/shadow
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { FS=":"; OFS=":" } \
 		 /^[ \t]*$$/ { next } \
@@ -128,7 +128,7 @@ $(VAR_DB)/shadow.db: /etc/shadow
 	  echo; \
 	fi
 
-$(VAR_DB)/gshadow.db: /etc/gshadow
+$(VAR_DB)/gshadow.db: /data/data/com.termux/files/usr/etc/gshadow
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { FS=":"; OFS=":" } \
 		 /^[ \t]*$$/ { next } \
@@ -148,7 +148,7 @@ $(VAR_DB)/gshadow.db: /etc/gshadow
 	  echo; \
 	fi
 
-$(VAR_DB)/netgroup.db: /etc/netgroup
+$(VAR_DB)/netgroup.db: /data/data/com.termux/files/usr/etc/netgroup
 	@printf %s "$(patsubst %.db,%,$(@F))... "
 	@$(AWK) 'BEGIN { ini=1 } \
 		 /^[ \t]*$$/ { next } \
diff -Narupa a/nss/getgrgid.c b/nss/getgrgid.c
--- a/nss/getgrgid.c
+++ b/nss/getgrgid.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	gid_t gid
 #define ADD_VARIABLES	gid
 #define BUFLEN		NSS_BUFLEN_GROUP
+#define ANDROID_SYS	getgrgid_android
 
 #include "../nss/getXXbyYY.c"
diff -Narupa a/nss/getgrgid_r.c b/nss/getgrgid_r.c
--- a/nss/getgrgid_r.c
+++ b/nss/getgrgid_r.c
@@ -27,5 +27,6 @@
 #define BUFLEN		NSS_BUFLEN_GROUP
 #define DEEPCOPY_FN	__copy_grp
 #define MERGE_FN	__merge_grp
+#define ANDROID_SYS	getgrgid_android
 
 #include <nss/getXXbyYY_r.c>
diff -Narupa a/nss/getgrnam.c b/nss/getgrnam.c
--- a/nss/getgrnam.c
+++ b/nss/getgrnam.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
 #define BUFLEN		NSS_BUFLEN_GROUP
+#define ANDROID_SYS	getgrnam_android
 
 #include "../nss/getXXbyYY.c"
diff -Narupa a/nss/getgrnam_r.c b/nss/getgrnam_r.c
--- a/nss/getgrnam_r.c
+++ b/nss/getgrnam_r.c
@@ -24,6 +24,7 @@
 #define DATABASE_NAME	group
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
+#define ANDROID_SYS	getgrnam_android
 
 #define DEEPCOPY_FN	__copy_grp
 #define MERGE_FN	__merge_grp
diff -Narupa a/nss/getpwnam.c b/nss/getpwnam.c
--- a/nss/getpwnam.c
+++ b/nss/getpwnam.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwnam_android
 
 #include "../nss/getXXbyYY.c"
diff -Narupa a/nss/getpwnam_r.c b/nss/getpwnam_r.c
--- a/nss/getpwnam_r.c
+++ b/nss/getpwnam_r.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	const char *name
 #define ADD_VARIABLES	name
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwnam_android
 
 #include <nss/getXXbyYY_r.c>
diff -Narupa a/nss/getpwuid.c b/nss/getpwuid.c
--- a/nss/getpwuid.c
+++ b/nss/getpwuid.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	uid_t uid
 #define ADD_VARIABLES	uid
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwuid_android
 
 #include "../nss/getXXbyYY.c"
diff -Narupa a/nss/getpwuid_r.c b/nss/getpwuid_r.c
--- a/nss/getpwuid_r.c
+++ b/nss/getpwuid_r.c
@@ -24,5 +24,6 @@
 #define ADD_PARAMS	uid_t uid
 #define ADD_VARIABLES	uid
 #define BUFLEN		NSS_BUFLEN_PASSWD
+#define ANDROID_SYS	getpwuid_android
 
 #include <nss/getXXbyYY_r.c>
diff -Narupa a/nss/getXXbyYY.c b/nss/getXXbyYY.c
--- a/nss/getXXbyYY.c
+++ b/nss/getXXbyYY.c
@@ -53,6 +53,10 @@
 # include <resolv/resolv_context.h>
 #endif
 
+#ifdef ANDROID_SYS
+# include "android_passwd_group.h"
+#endif
+
 /* To make the real sources a bit prettier.  */
 #define REENTRANT_NAME APPEND_R (FUNCTION_NAME)
 #define APPEND_R(name) APPEND_R1 (name)
@@ -176,6 +180,11 @@ done:
     __set_h_errno (h_errno_tmp);
 #endif
 
+#ifdef ANDROID_SYS
+  if (result == NULL)
+    result = ANDROID_SYS (ADD_VARIABLES);
+#endif
+
   return result;
 }
 
diff -Narupa a/nss/getXXbyYY_r.c b/nss/getXXbyYY_r.c
--- a/nss/getXXbyYY_r.c
+++ b/nss/getXXbyYY_r.c
@@ -27,6 +27,9 @@
 #ifdef NEED__RES
 # include <resolv/resolv_context.h>
 #endif
+#ifdef ANDROID_SYS
+# include "android_passwd_group.h"
+#endif
 /*******************************************************************\
 |* Here we assume several symbols to be defined:		   *|
 |*								   *|
@@ -349,6 +352,15 @@ INTERNAL (REENTRANT_NAME) (ADD_PARAMS, L
 #ifdef HANDLE_DIGITS_DOTS
 done:
 #endif
+#ifdef ANDROID_SYS
+  if (status != NSS_STATUS_SUCCESS) {
+    LOOKUP_TYPE *android_buf = ANDROID_SYS (ADD_VARIABLES);
+    if (android_buf != NULL) {
+      *resbuf = *android_buf;
+      status = NSS_STATUS_SUCCESS;
+    }
+  }
+#endif
   *result = status == NSS_STATUS_SUCCESS ? resbuf : NULL;
 #ifdef NEED_H_ERRNO
   if (status == NSS_STATUS_UNAVAIL && !any_service && errno != ENOENT)
diff -Narupa a/nss/Makefile b/nss/Makefile
--- a/nss/Makefile
+++ b/nss/Makefile
@@ -53,6 +53,7 @@ routines = \
   rewrite_field \
   valid_field \
   valid_list_field \
+  android_passwd_group \
   # routines
 
 # alias routines:
diff -Narupa a/nss/nss_compat/compat-grp.c b/nss/nss_compat/compat-grp.c
--- a/nss/nss_compat/compat-grp.c
+++ b/nss/nss_compat/compat-grp.c
@@ -108,7 +108,7 @@ internal_setgrent (ent_t *ent, int stayo
 
   if (ent->stream == NULL)
     {
-      ent->stream = __nss_files_fopen ("/etc/group");
+      ent->stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/group");
 
       if (ent->stream == NULL)
 	status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;
diff -Narupa a/nss/nss_compat/compat-initgroups.c b/nss/nss_compat/compat-initgroups.c
--- a/nss/nss_compat/compat-initgroups.c
+++ b/nss/nss_compat/compat-initgroups.c
@@ -122,7 +122,7 @@ internal_setgrent (ent_t *ent)
   else
     ent->blacklist.current = 0;
 
-  ent->stream = __nss_files_fopen ("/etc/group");
+  ent->stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/group");
 
   if (ent->stream == NULL)
     status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;
diff -Narupa a/nss/nss_compat/compat-pwd.c b/nss/nss_compat/compat-pwd.c
--- a/nss/nss_compat/compat-pwd.c
+++ b/nss/nss_compat/compat-pwd.c
@@ -223,7 +223,7 @@ internal_setpwent (ent_t *ent, int stayo
 
   if (ent->stream == NULL)
     {
-      ent->stream = __nss_files_fopen ("/etc/passwd");
+      ent->stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/passwd");
 
       if (ent->stream == NULL)
 	status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;
diff -Narupa a/nss/nss_compat/compat-spwd.c b/nss/nss_compat/compat-spwd.c
--- a/nss/nss_compat/compat-spwd.c
+++ b/nss/nss_compat/compat-spwd.c
@@ -178,7 +178,7 @@ internal_setspent (ent_t *ent, int stayo
 
   if (ent->stream == NULL)
     {
-      ent->stream = __nss_files_fopen ("/etc/shadow");
+      ent->stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/shadow");
 
       if (ent->stream == NULL)
 	status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;
diff -Narupa a/nss/nss_files/files-alias.c b/nss/nss_files/files-alias.c
--- a/nss/nss_files/files-alias.c
+++ b/nss/nss_files/files-alias.c
@@ -42,7 +42,7 @@ internal_setent (FILE **stream)
 
   if (*stream == NULL)
     {
-      *stream = __nss_files_fopen ("/etc/aliases");
+      *stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/aliases");
 
       if (*stream == NULL)
 	status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;
@@ -58,7 +58,7 @@ internal_setent (FILE **stream)
 enum nss_status
 _nss_files_setaliasent (void)
 {
-  return __nss_files_data_setent (nss_file_aliasent, "/etc/aliases");
+  return __nss_files_data_setent (nss_file_aliasent, "/data/data/com.termux/files/usr/etc/aliases");
 }
 libc_hidden_def (_nss_files_setaliasent)
 
@@ -338,7 +338,7 @@ _nss_files_getaliasent_r (struct aliasen
 
   struct nss_files_per_file_data *data;
   enum nss_status status = __nss_files_data_open (&data, nss_file_aliasent,
-						  "/etc/aliases", errnop, NULL);
+						  "/data/data/com.termux/files/usr/etc/aliases", errnop, NULL);
   if (status != NSS_STATUS_SUCCESS)
     return status;
 
diff -Narupa a/nss/nss_files/files-init.c b/nss/nss_files/files-init.c
--- a/nss/nss_files/files-init.c
+++ b/nss/nss_files/files-init.c
@@ -41,12 +41,12 @@ register_file (void (*cb) (size_t, struc
 void
 _nss_files_init (void (*cb) (size_t, struct traced_file *))
 {
-  register_file (cb, pwddb, "/etc/passwd", 0);
-  register_file (cb, grpdb, "/etc/group", 0);
-  register_file (cb, hstdb, "/etc/hosts", 0);
-  register_file (cb, hstdb, "/etc/resolv.conf", 1);
-  register_file (cb, servdb, "/etc/services", 0);
-  register_file (cb, netgrdb, "/etc/netgroup", 0);
+  register_file (cb, pwddb, "/data/data/com.termux/files/usr/etc/passwd", 0);
+  register_file (cb, grpdb, "/data/data/com.termux/files/usr/etc/group", 0);
+  register_file (cb, hstdb, "/system/etc/hosts", 0);
+  register_file (cb, hstdb, "/data/data/com.termux/files/usr/etc/resolv.conf", 1);
+  register_file (cb, servdb, "/data/data/com.termux/files/usr/etc/services", 0);
+  register_file (cb, netgrdb, "/data/data/com.termux/files/usr/etc/netgroup", 0);
 }
 libc_hidden_def (_nss_files_init)
 
diff -Narupa a/nss/nss_files/files-initgroups.c b/nss/nss_files/files-initgroups.c
--- a/nss/nss_files/files-initgroups.c
+++ b/nss/nss_files/files-initgroups.c
@@ -33,7 +33,7 @@ _nss_files_initgroups_dyn (const char *u
 			   long int *size, gid_t **groupsp, long int limit,
 			   int *errnop)
 {
-  FILE *stream = __nss_files_fopen ("/etc/group");
+  FILE *stream = __nss_files_fopen ("/data/data/com.termux/files/usr/etc/group");
   if (stream == NULL)
     {
       *errnop = errno;
diff -Narupa a/nss/nss_files/files-netgrp.c b/nss/nss_files/files-netgrp.c
--- a/nss/nss_files/files-netgrp.c
+++ b/nss/nss_files/files-netgrp.c
@@ -27,7 +27,7 @@
 #include "netgroup.h"
 #include <nss_files.h>
 
-#define DATAFILE	"/etc/netgroup"
+#define DATAFILE	"/data/data/com.termux/files/usr/etc/netgroup"
 
 libc_hidden_proto (_nss_files_endnetgrent)
 
diff -Narupa a/nss/nss_files/files-XXX.c b/nss/nss_files/files-XXX.c
--- a/nss/nss_files/files-XXX.c
+++ b/nss/nss_files/files-XXX.c
@@ -39,7 +39,7 @@
 
 #define ENTNAME_r	CONCAT(ENTNAME,_r)
 
-#define DATAFILE	"/etc/" DATABASE
+#define DATAFILE	"/data/data/com.termux/files/usr/etc/" DATABASE
 
 #ifdef NEED_H_ERRNO
 # include <netdb.h>
diff -Narupa a/posix/annexc.c b/posix/annexc.c
--- a/posix/annexc.c
+++ b/posix/annexc.c
@@ -26,7 +26,7 @@
 
 #define HEADER_MAX          256
 
-static char macrofile[] = "/tmp/annexc.XXXXXX";
+static char macrofile[] = "/data/data/com.termux/files/usr/tmp/annexc.XXXXXX";
 
 /* <aio.h>.  */
 static const char *const aio_syms[] =
diff -Narupa a/posix/bug-getopt1.c b/posix/bug-getopt1.c
--- a/posix/bug-getopt1.c
+++ b/posix/bug-getopt1.c
@@ -40,7 +40,7 @@ one_test (const char *fmt, int argc, cha
 static int
 do_test (void)
 {
-  char fname[] = "/tmp/bug-getopt1.XXXXXX";
+  char fname[] = "/data/data/com.termux/files/usr/tmp/bug-getopt1.XXXXXX";
   int fd = mkstemp (fname);
   if (fd == -1)
     {
diff -Narupa a/posix/bug-getopt2.c b/posix/bug-getopt2.c
--- a/posix/bug-getopt2.c
+++ b/posix/bug-getopt2.c
@@ -38,7 +38,7 @@ one_test (const char *fmt, int argc, cha
 static int
 do_test (void)
 {
-  char fname[] = "/tmp/bug-getopt2.XXXXXX";
+  char fname[] = "/data/data/com.termux/files/usr/tmp/bug-getopt2.XXXXXX";
   int fd = mkstemp (fname);
   if (fd == -1)
     {
diff -Narupa a/posix/bug-getopt3.c b/posix/bug-getopt3.c
--- a/posix/bug-getopt3.c
+++ b/posix/bug-getopt3.c
@@ -49,7 +49,7 @@ one_test (const char *fmt, int argc, cha
 static int
 do_test (void)
 {
-  char fname[] = "/tmp/bug-getopt3.XXXXXX";
+  char fname[] = "/data/data/com.termux/files/usr/tmp/bug-getopt3.XXXXXX";
   int fd = mkstemp (fname);
   if (fd == -1)
     {
diff -Narupa a/posix/bug-getopt4.c b/posix/bug-getopt4.c
--- a/posix/bug-getopt4.c
+++ b/posix/bug-getopt4.c
@@ -53,7 +53,7 @@ one_test (const char *fmt, int argc, cha
 static int
 do_test (void)
 {
-  char fname[] = "/tmp/bug-getopt4.XXXXXX";
+  char fname[] = "/data/data/com.termux/files/usr/tmp/bug-getopt4.XXXXXX";
   int fd = mkstemp (fname);
   if (fd == -1)
     {
diff -Narupa a/posix/bug-getopt5.c b/posix/bug-getopt5.c
--- a/posix/bug-getopt5.c
+++ b/posix/bug-getopt5.c
@@ -48,7 +48,7 @@ one_test (const char *fmt, int argc, cha
 static int
 do_test (void)
 {
-  char fname[] = "/tmp/bug-getopt5.XXXXXX";
+  char fname[] = "/data/data/com.termux/files/usr/tmp/bug-getopt5.XXXXXX";
   int fd = mkstemp (fname);
   if (fd == -1)
     {
diff -Narupa a/posix/bug-regex9.c b/posix/bug-regex9.c
--- a/posix/bug-regex9.c
+++ b/posix/bug-regex9.c
@@ -23,7 +23,7 @@
 #include <stdlib.h>
 
 
-static const char text[] = "#! /bin/sh";
+static const char text[] = "#! /data/data/com.termux/files/usr/bin/sh";
 
 int
 main (void)
diff -Narupa a/posix/unistd.h b/posix/unistd.h
--- a/posix/unistd.h
+++ b/posix/unistd.h
@@ -1088,6 +1088,7 @@ extern void *sbrk (intptr_t __delta) __T
 
    In Mach, all system calls take normal arguments and always return an
    error code (zero for success).  */
+extern long int syscallS (long int __sysno, ...) __THROW;
 extern long int syscall (long int __sysno, ...) __THROW;
 
 #endif	/* Use misc.  */
diff -Narupa a/resolv/netdb.h b/resolv/netdb.h
--- a/resolv/netdb.h
+++ b/resolv/netdb.h
@@ -40,12 +40,12 @@
 #include <bits/netdb.h>
 
 /* Absolute file name for network data base files.  */
-#define	_PATH_HEQUIV		"/etc/hosts.equiv"
+#define	_PATH_HEQUIV		"/data/data/com.termux/files/usr/etc/hosts.equiv"
 #define	_PATH_HOSTS		"/etc/hosts"
-#define	_PATH_NETWORKS		"/etc/networks"
-#define	_PATH_NSSWITCH_CONF	"/etc/nsswitch.conf"
-#define	_PATH_PROTOCOLS		"/etc/protocols"
-#define	_PATH_SERVICES		"/etc/services"
+#define	_PATH_NETWORKS		"/data/data/com.termux/files/usr/etc/networks"
+#define	_PATH_NSSWITCH_CONF	"/data/data/com.termux/files/usr/etc/nsswitch.conf"
+#define	_PATH_PROTOCOLS		"/data/data/com.termux/files/usr/etc/protocols"
+#define	_PATH_SERVICES		"/data/data/com.termux/files/usr/etc/services"
 
 
 __BEGIN_DECLS
diff -Narupa a/resolv/resolv.h b/resolv/resolv.h
--- a/resolv/resolv.h
+++ b/resolv/resolv.h
@@ -91,7 +91,7 @@
  */
 
 #ifndef _PATH_RESCONF
-#define _PATH_RESCONF        "/etc/resolv.conf"
+#define _PATH_RESCONF        "/data/data/com.termux/files/usr/etc/resolv.conf"
 #endif
 
 struct res_sym {
diff -Narupa a/stdio-common/bug7.c b/stdio-common/bug7.c
--- a/stdio-common/bug7.c
+++ b/stdio-common/bug7.c
@@ -8,7 +8,7 @@ int
 main (int argc, char *argv[])
 {
   int lose = 0;
-  char filename[] = "/tmp/bug7.XXXXXX";
+  char filename[] = "/data/data/com.termux/files/usr/tmp/bug7.XXXXXX";
   FILE *fp;
 
   int fd = mkstemp (filename);
@@ -36,8 +36,8 @@ main (int argc, char *argv[])
   {
     FILE *file1;
     FILE *file2;
-    char filename1[] = "/tmp/bug7.XXXXXX";
-    char filename2[] = "/tmp/bug7.XXXXXX";
+    char filename1[] = "/data/data/com.termux/files/usr/tmp/bug7.XXXXXX";
+    char filename2[] = "/data/data/com.termux/files/usr/tmp/bug7.XXXXXX";
     int ch;
 
     int fd1 = mkstemp (filename1);
diff -Narupa a/stdio-common/scanf14.c b/stdio-common/scanf14.c
--- a/stdio-common/scanf14.c
+++ b/stdio-common/scanf14.c
@@ -82,7 +82,7 @@ main (void)
 
   const char *tmpdir = getenv ("TMPDIR");
   if (tmpdir == NULL || tmpdir[0] == '\0')
-    tmpdir = "/tmp";
+    tmpdir = "/data/data/com.termux/files/usr/tmp";
 
   char fname[strlen (tmpdir) + sizeof "/tst-scanf14.XXXXXX"];
   sprintf (fname, "%s/tst-scanf14.XXXXXX", tmpdir);
diff -Narupa a/stdio-common/scanf15.c b/stdio-common/scanf15.c
--- a/stdio-common/scanf15.c
+++ b/stdio-common/scanf15.c
@@ -65,7 +65,7 @@ main (void)
 
   const char *tmpdir = getenv ("TMPDIR");
   if (tmpdir == NULL || tmpdir[0] == '\0')
-    tmpdir = "/tmp";
+    tmpdir = "/data/data/com.termux/files/usr/tmp";
 
   char fname[strlen (tmpdir) + sizeof "/tst-scanf15.XXXXXX"];
   sprintf (fname, "%s/tst-scanf15.XXXXXX", tmpdir);
diff -Narupa a/stdio-common/scanf16.c b/stdio-common/scanf16.c
--- a/stdio-common/scanf16.c
+++ b/stdio-common/scanf16.c
@@ -113,7 +113,7 @@ main (void)
 
   const char *tmpdir = getenv ("TMPDIR");
   if (tmpdir == NULL || tmpdir[0] == '\0')
-    tmpdir = "/tmp";
+    tmpdir = "/data/data/com.termux/files/usr/tmp";
 
   char fname[strlen (tmpdir) + sizeof "/tst-scanf16.XXXXXX"];
   sprintf (fname, "%s/tst-scanf16.XXXXXX", tmpdir);
diff -Narupa a/stdio-common/scanf17.c b/stdio-common/scanf17.c
--- a/stdio-common/scanf17.c
+++ b/stdio-common/scanf17.c
@@ -96,7 +96,7 @@ main (void)
 
   const char *tmpdir = getenv ("TMPDIR");
   if (tmpdir == NULL || tmpdir[0] == '\0')
-    tmpdir = "/tmp";
+    tmpdir = "/data/data/com.termux/files/usr/tmp";
 
   char fname[strlen (tmpdir) + sizeof "/tst-scanf17.XXXXXX"];
   sprintf (fname, "%s/tst-scanf17.XXXXXX", tmpdir);
diff -Narupa a/stdio-common/tstscanf.c b/stdio-common/tstscanf.c
--- a/stdio-common/tstscanf.c
+++ b/stdio-common/tstscanf.c
@@ -62,7 +62,7 @@ main (int argc, char **argv)
 
   if (argc == 2 && !strcmp (argv[1], "-opipe"))
     {
-      out = popen ("/bin/cat", "w");
+      out = popen ("/data/data/com.termux/files/usr/bin/cat", "w");
       if (out == NULL)
 	{
 	  perror ("popen: /bin/cat");
@@ -71,7 +71,7 @@ main (int argc, char **argv)
     }
   else if (argc == 3 && !strcmp (argv[1], "-ipipe"))
     {
-      sprintf (buf, "/bin/cat %s", argv[2]);
+      sprintf (buf, "/data/data/com.termux/files/usr/bin/cat %s", argv[2]);
       in = popen (buf, "r");
       if (in == NULL)
 	{
diff -Narupa a/stdio-common/xbug.c b/stdio-common/xbug.c
--- a/stdio-common/xbug.c
+++ b/stdio-common/xbug.c
@@ -60,7 +60,7 @@ main(int argc, char *argv[])
 
   unsetenv ("LD_LIBRARY_PATH");
 
-  if (!(input = popen("/bin/cat", "r")))
+  if (!(input = popen("/data/data/com.termux/files/usr/bin/cat", "r")))
     fprintf(stderr, "cannot run \n");
 
   ReadFile(&buffer, input);
diff -Narupa a/stdlib/isomac.c b/stdlib/isomac.c
--- a/stdlib/isomac.c
+++ b/stdlib/isomac.c
@@ -74,7 +74,7 @@
 
 #define HEADER_MAX          256
 
-static char macrofile[] = "/tmp/isomac.XXXXXX";
+static char macrofile[] = "/data/data/com.termux/files/usr/tmp/isomac.XXXXXX";
 
 /* ISO C header names including Amendment 1 (without ".h" suffix).  */
 static char *header[] =
diff -Narupa a/support/support_test_main.c b/support/support_test_main.c
--- a/support/support_test_main.c
+++ b/support/support_test_main.c
@@ -351,7 +351,7 @@ support_test_main (int argc, char **argv
     {
       test_dir = getenv ("TMPDIR");
       if (test_dir == NULL || test_dir[0] == '\0')
-        test_dir = "/tmp";
+        test_dir = "/data/data/com.termux/files/usr/tmp";
     }
   if (support_set_test_dir != NULL)
     support_set_test_dir (test_dir);
diff -Narupa a/sysdeps/generic/paths.h b/sysdeps/generic/paths.h
--- a/sysdeps/generic/paths.h
+++ b/sysdeps/generic/paths.h
@@ -33,43 +33,43 @@
 #define	_PATHS_H_
 
 /* Default search path. */
-#define	_PATH_DEFPATH	"/usr/bin:/bin"
+#define	_PATH_DEFPATH	"/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin:/system/bin"
 /* All standard utilities path. */
 #define	_PATH_STDPATH \
-	"/usr/bin:/bin:/usr/sbin:/sbin"
+	"/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin:/system/bin"
 
-#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_BSHELL	"/data/data/com.termux/files/usr/bin/sh"
 #define	_PATH_CONSOLE	"/dev/console"
-#define	_PATH_CSHELL	"/bin/csh"
-#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_CSHELL	"/data/data/com.termux/files/usr/bin/csh"
+#define	_PATH_DEVDB	"/data/data/com.termux/files/usr/var/run/dev.db"
 #define	_PATH_DEVNULL	"/dev/null"
 #define	_PATH_DRUM	"/dev/drum"
-#define	_PATH_GSHADOW	"/etc/gshadow"
+#define	_PATH_GSHADOW	"/data/data/com.termux/files/usr/etc/gshadow"
 #define	_PATH_KMEM	"/dev/kmem"
-#define	_PATH_LASTLOG	"/var/log/lastlog"
-#define	_PATH_MAILDIR	"/var/mail"
-#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_LASTLOG	"/data/data/com.termux/files/usr/var/log/lastlog"
+#define	_PATH_MAILDIR	"/data/data/com.termux/files/usr/var/mail"
+#define	_PATH_MAN	"/data/data/com.termux/files/usr/share/man"
 #define	_PATH_MEM	"/dev/mem"
-#define	_PATH_MNTTAB	"/etc/fstab"
-#define	_PATH_MOUNTED	"/var/run/mtab"
-#define	_PATH_NOLOGIN	"/etc/nologin"
-#define	_PATH_PRESERVE	"/var/lib"
-#define	_PATH_RWHODIR	"/var/spool/rwho"
-#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
-#define	_PATH_SHADOW	"/etc/shadow"
-#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_MNTTAB	"/data/data/com.termux/files/usr/etc/fstab"
+#define	_PATH_MOUNTED	"/data/data/com.termux/files/usr/var/run/mtab"
+#define	_PATH_NOLOGIN	"/data/data/com.termux/files/usr/etc/nologin"
+#define	_PATH_PRESERVE	"/data/data/com.termux/files/usr/var/lib"
+#define	_PATH_RWHODIR	"/data/data/com.termux/files/usr/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/data/data/com.termux/files/usr/bin/sendmail"
+#define	_PATH_SHADOW	"/data/data/com.termux/files/usr/etc/shadow"
+#define	_PATH_SHELLS	"/data/data/com.termux/files/usr/etc/shells"
 #define	_PATH_TTY	"/dev/tty"
 #define	_PATH_UNIX	"/vmunix"
-#define	_PATH_UTMP	"/var/run/utmp"
-#define	_PATH_UTMP_DB	"/var/run/utmp.db"
-#define	_PATH_VI	"/usr/bin/vi"
-#define	_PATH_WTMP	"/var/log/wtmp"
+#define	_PATH_UTMP	"/data/data/com.termux/files/usr/var/run/utmp"
+#define	_PATH_UTMP_DB	"/data/data/com.termux/files/usr/var/run/utmp.db"
+#define	_PATH_VI	"/data/data/com.termux/files/usr/bin/vi"
+#define	_PATH_WTMP	"/data/data/com.termux/files/usr/var/log/wtmp"
 
 /* Provide trailing slash, since mostly used for building pathnames. */
 #define	_PATH_DEV	"/dev/"
-#define	_PATH_TMP	"/tmp/"
-#define	_PATH_VARDB	"/var/db/"
-#define	_PATH_VARRUN	"/var/run/"
-#define	_PATH_VARTMP	"/var/tmp/"
+#define	_PATH_TMP	"/data/data/com.termux/files/usr/tmp/"
+#define	_PATH_VARDB	"/data/data/com.termux/files/usr/var/db/"
+#define	_PATH_VARRUN	"/data/data/com.termux/files/usr/var/run/"
+#define	_PATH_VARTMP	"/data/data/com.termux/files/usr/var/tmp/"
 
 #endif /* !_PATHS_H_ */
diff -Narupa a/sysdeps/nptl/dl-tls_init_tp.c b/sysdeps/nptl/dl-tls_init_tp.c
--- a/sysdeps/nptl/dl-tls_init_tp.c
+++ b/sysdeps/nptl/dl-tls_init_tp.c
@@ -90,14 +90,9 @@ __tls_init_tp (void)
     pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
                                     - offsetof (pthread_mutex_t,
                                                 __data.__list.__next));
-    int res = INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-                                     sizeof (struct robust_list_head));
-    if (!INTERNAL_SYSCALL_ERROR_P (res))
-      {
 #ifndef __ASSUME_SET_ROBUST_LIST
         __nptl_set_robust_list_avail = true;
 #endif
-      }
   }
 
   {
diff -Narupa a/sysdeps/nptl/_Fork.c b/sysdeps/nptl/_Fork.c
--- a/sysdeps/nptl/_Fork.c
+++ b/sysdeps/nptl/_Fork.c
@@ -41,8 +41,6 @@ _Fork (void)
       self->robust_prev = &self->robust_head;
 #endif
       self->robust_head.list = &self->robust_head;
-      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,
-			     sizeof (struct robust_list_head));
     }
   return pid;
 }
diff -Narupa a/sysdeps/posix/system.c b/sysdeps/posix/system.c
--- a/sysdeps/posix/system.c
+++ b/sysdeps/posix/system.c
@@ -31,7 +31,7 @@
 #include <not-cancel.h>
 #include <internal-signals.h>
 
-#define	SHELL_PATH	"/bin/sh"	/* Path of the shell.  */
+#define	SHELL_PATH	"/data/data/com.termux/files/usr/bin/sh"	/* Path of the shell.  */
 #define	SHELL_NAME	"sh"		/* Name to give it.  */
 
 
diff -Narupa a/sysdeps/posix/tempname.c b/sysdeps/posix/tempname.c
--- a/sysdeps/posix/tempname.c
+++ b/sysdeps/posix/tempname.c
@@ -28,7 +28,7 @@
 
 #include <stdio.h>
 #ifndef P_tmpdir
-# define P_tmpdir "/tmp"
+# define P_tmpdir "/data/data/com.termux/files/usr/tmp"
 #endif
 #ifndef TMP_MAX
 # define TMP_MAX 238328
@@ -141,8 +141,8 @@ __path_search (char *tmpl, size_t tmpl_l
     {
       if (direxists (P_tmpdir))
         dir = P_tmpdir;
-      else if (strcmp (P_tmpdir, "/tmp") != 0 && direxists ("/tmp"))
-        dir = "/tmp";
+      else if (strcmp (P_tmpdir, "/data/data/com.termux/files/usr/tmp") != 0 && direxists ("/data/data/com.termux/files/usr/tmp"))
+        dir = "/data/data/com.termux/files/usr/tmp";
       else
         {
           __set_errno (ENOENT);
diff -Narupa a/sysdeps/pthread/sem_open.c b/sysdeps/pthread/sem_open.c
--- a/sysdeps/pthread/sem_open.c
+++ b/sysdeps/pthread/sem_open.c
@@ -28,7 +28,7 @@
 
 #if !PTHREAD_IN_LIBC
 /* The private names are not exported from libc.  */
-# define __link link
+# define __symlink symlink
 # define __unlink unlink
 #endif
 
@@ -166,7 +166,7 @@ __sem_open (const char *name, int oflag,
 					 fd, 0)) != MAP_FAILED)
 	{
 	  /* Create the file.  Don't overwrite an existing file.  */
-	  if (__link (tmpfname, dirname.name) != 0)
+	  if (__symlink (tmpfname, dirname.name) != 0)
 	    {
 	      /* Undo the mapping.  */
 	      __munmap (result, sizeof (sem_t));
diff -Narupa a/sysdeps/unix/confstr.h b/sysdeps/unix/confstr.h
--- a/sysdeps/unix/confstr.h
+++ b/sysdeps/unix/confstr.h
@@ -1 +1 @@
-#define	CS_PATH	"/bin:/usr/bin"
+#define	CS_PATH	"/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin:/system/bin"
diff -Narupa a/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h b/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
--- a/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/aarch64/arch-syscall.h
@@ -1,5 +1,4 @@
 /* AUTOGENERATED by update-syscall-lists.py.  */
-#define __NR_accept 202
 #define __NR_accept4 242
 #define __NR_acct 89
 #define __NR_add_key 217
@@ -18,9 +17,7 @@
 #define __NR_clock_nanosleep 115
 #define __NR_clock_settime 112
 #define __NR_clone 220
-#define __NR_clone3 435
 #define __NR_close 57
-#define __NR_close_range 436
 #define __NR_connect 203
 #define __NR_copy_file_range 285
 #define __NR_delete_module 106
@@ -29,14 +26,12 @@
 #define __NR_epoll_create1 20
 #define __NR_epoll_ctl 21
 #define __NR_epoll_pwait 22
-#define __NR_epoll_pwait2 441
 #define __NR_eventfd2 19
 #define __NR_execve 221
 #define __NR_execveat 281
 #define __NR_exit 93
 #define __NR_exit_group 94
 #define __NR_faccessat 48
-#define __NR_faccessat2 439
 #define __NR_fadvise64 223
 #define __NR_fallocate 47
 #define __NR_fanotify_init 262
@@ -44,7 +39,6 @@
 #define __NR_fchdir 50
 #define __NR_fchmod 52
 #define __NR_fchmodat 53
-#define __NR_fchmodat2 452
 #define __NR_fchown 55
 #define __NR_fchownat 54
 #define __NR_fcntl 25
@@ -66,7 +60,6 @@
 #define __NR_futex 98
 #define __NR_futex_requeue 456
 #define __NR_futex_wait 455
-#define __NR_futex_waitv 449
 #define __NR_futex_wake 454
 #define __NR_get_mempolicy 236
 #define __NR_get_robust_list 100
@@ -117,7 +110,6 @@
 #define __NR_keyctl 219
 #define __NR_kill 129
 #define __NR_landlock_add_rule 445
-#define __NR_landlock_create_ruleset 444
 #define __NR_landlock_restrict_self 446
 #define __NR_lgetxattr 9
 #define __NR_linkat 37
@@ -174,7 +166,6 @@
 #define __NR_personality 92
 #define __NR_pidfd_getfd 438
 #define __NR_pidfd_open 434
-#define __NR_pidfd_send_signal 424
 #define __NR_pipe2 59
 #define __NR_pivot_root 41
 #define __NR_pkey_alloc 289
@@ -211,7 +202,6 @@
 #define __NR_renameat2 276
 #define __NR_request_key 218
 #define __NR_restart_syscall 128
-#define __NR_rseq 293
 #define __NR_rt_sigaction 134
 #define __NR_rt_sigpending 136
 #define __NR_rt_sigprocmask 135
@@ -243,12 +233,8 @@
 #define __NR_sendto 206
 #define __NR_set_mempolicy 237
 #define __NR_set_mempolicy_home_node 450
-#define __NR_set_robust_list 99
 #define __NR_set_tid_address 96
 #define __NR_setdomainname 162
-#define __NR_setfsgid 152
-#define __NR_setfsuid 151
-#define __NR_setgid 144
 #define __NR_setgroups 159
 #define __NR_sethostname 161
 #define __NR_setitimer 103
@@ -256,14 +242,12 @@
 #define __NR_setpgid 154
 #define __NR_setpriority 140
 #define __NR_setregid 143
-#define __NR_setresgid 149
 #define __NR_setresuid 147
 #define __NR_setreuid 145
 #define __NR_setrlimit 164
 #define __NR_setsid 157
 #define __NR_setsockopt 208
 #define __NR_settimeofday 170
-#define __NR_setuid 146
 #define __NR_setxattr 5
 #define __NR_shmat 196
 #define __NR_shmctl 195
@@ -276,7 +260,6 @@
 #define __NR_socketpair 199
 #define __NR_splice 76
 #define __NR_statfs 43
-#define __NR_statx 291
 #define __NR_swapoff 225
 #define __NR_swapon 224
 #define __NR_symlinkat 36
diff -Narupa a/sysdeps/unix/sysv/linux/aarch64/clone3.S b/sysdeps/unix/sysv/linux/aarch64/clone3.S
--- a/sysdeps/unix/sysv/linux/aarch64/clone3.S
+++ b/sysdeps/unix/sysv/linux/aarch64/clone3.S
@@ -1,85 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/aarch64 version.
-   Copyright (C) 2023-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#define _ERRNO_H        1
-#include <bits/errno.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-               int (*func)(void *arg), void *arg);
-
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   x0: cl_args
-   x1: size
-   x2: func
-   x3: arg  */
-
-        .text
-ENTRY(__clone3)
-	PTR_ARG (0)
-	PTR_ARG (1)
-	PTR_ARG (3)
-	PTR_ARG (4)
-	/* Save args for the child.  */
-	mov	x10, x0		/* cl_args  */
-	mov	x11, x2		/* func	 */
-	mov	x12, x3		/* args  */
-
-	/* Sanity check args.  */
-	mov	x0, #-EINVAL
-	cbz	x10, .Lsyscall_error	/* No NULL cl_args pointer.  */
-	cbz	x2, .Lsyscall_error	/* No NULL function pointer.  */
-
-	/* Do the system call, the kernel expects:
-	   x8: system call number
-	   x0: cl_args
-	   x1: size  */
-	mov	x0, x10
-	mov	x8, #SYS_ify(clone3)
-	svc	0x0
-
-	cmp	x0, #0
-	beq	thread_start
-	blt	.Lsyscall_error
-	RET
-PSEUDO_END (__clone3)
-
-	.align 4
-	.type thread_start, %function
-thread_start:
-	cfi_startproc
-	cfi_undefined (x30)
-	mov	x29, 0
-
-	/* Pick the function arg and execute.  */
-	mov	x0, x12
-	blr	x11
-
-	/* We are done, pass the return value through x0.  */
-	mov	x8, #SYS_ify(exit)
-	svc	0x0
-	cfi_endproc
-	.size thread_start, .-thread_start
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/aarch64/disabled-syscall.h b/sysdeps/unix/sysv/linux/aarch64/disabled-syscall.h
--- a/sysdeps/unix/sysv/linux/aarch64/disabled-syscall.h
+++ b/sysdeps/unix/sysv/linux/aarch64/disabled-syscall.h
@@ -0,0 +1,17 @@
+#define __NR_accept 202
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_epoll_pwait2 441
+#define __NR_faccessat2 439
+#define __NR_fchmodat2 452
+#define __NR_futex_waitv 449
+#define __NR_landlock_create_ruleset 444
+#define __NR_pidfd_send_signal 424
+#define __NR_rseq 293
+#define __NR_set_robust_list 99
+#define __NR_setfsgid 152
+#define __NR_setfsuid 151
+#define __NR_setgid 144
+#define __NR_setresgid 149
+#define __NR_setuid 146
+#define __NR_statx 291
diff -Narupa a/sysdeps/unix/sysv/linux/aarch64/syscall.S b/sysdeps/unix/sysv/linux/aarch64/syscall.S
--- a/sysdeps/unix/sysv/linux/aarch64/syscall.S
+++ b/sysdeps/unix/sysv/linux/aarch64/syscall.S
@@ -1,44 +0,0 @@
-/* Copyright (C) 2005-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-/* syscall (int nr, ...)
-
-   AArch64 system calls take between 0 and 7 arguments. On entry here nr
-   is in w0 and any other system call arguments are in register x1..x7.
-
-   For kernel entry we need to move the system call nr to x8 then
-   load the remaining arguments to register. */
-
-ENTRY (syscall)
-	uxtw	x8, w0
-	mov	x0, x1
-	mov	x1, x2
-	mov	x2, x3
-	mov	x3, x4
-	mov	x4, x5
-	mov	x5, x6
-	mov	x6, x7
-	svc	0x0
-	cmn	x0, #4095
-	b.cs	1f
-	RET
-1:
-	b	SYSCALL_ERROR
-PSEUDO_END (syscall)
diff -Narupa a/sysdeps/unix/sysv/linux/aarch64/syscallS.S b/sysdeps/unix/sysv/linux/aarch64/syscallS.S
--- a/sysdeps/unix/sysv/linux/aarch64/syscallS.S
+++ b/sysdeps/unix/sysv/linux/aarch64/syscallS.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 2005-2024 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* syscall (int nr, ...)
+
+   AArch64 system calls take between 0 and 7 arguments. On entry here nr
+   is in w0 and any other system call arguments are in register x1..x7.
+
+   For kernel entry we need to move the system call nr to x8 then
+   load the remaining arguments to register. */
+
+ENTRY (syscallS)
+	uxtw	x8, w0
+	mov	x0, x1
+	mov	x1, x2
+	mov	x2, x3
+	mov	x3, x4
+	mov	x4, x5
+	mov	x5, x6
+	mov	x6, x7
+	svc	0x0
+	cmn	x0, #4095
+	b.cs	1f
+	RET
+1:
+	b	SYSCALL_ERROR
+PSEUDO_END (syscallS)
diff -Narupa a/sysdeps/unix/sysv/linux/accept.c b/sysdeps/unix/sysv/linux/accept.c
--- a/sysdeps/unix/sysv/linux/accept.c
+++ b/sysdeps/unix/sysv/linux/accept.c
@@ -22,13 +22,7 @@
 int
 __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
-#ifdef __ASSUME_ACCEPT_SYSCALL
-  return SYSCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
-#elif defined __ASSUME_ACCEPT4_SYSCALL
   return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, len, 0);
-#else
-  return SOCKETCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
-#endif
 }
 weak_alias (__libc_accept, accept)
 libc_hidden_def (accept)
diff -Narupa a/sysdeps/unix/sysv/linux/arc/clone3.S b/sysdeps/unix/sysv/linux/arc/clone3.S
--- a/sysdeps/unix/sysv/linux/arc/clone3.S
+++ b/sysdeps/unix/sysv/linux/arc/clone3.S
@@ -1,90 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/arc version.
-   Copyright (C) 2023-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-               int (*func)(void *arg), void *arg);
-
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   r0: cl_args
-   r1: size
-   r2: func
-   r3: arg  */
-
-ENTRY(__clone3)
-
-	/* Save args for the child.  */
-	mov	r10, r0		/* cl_args  */
-	mov	r11, r2		/* func	 */
-	mov	r12, r3		/* args  */
-
-	/* Sanity check args.  */
-	breq	r10, 0, L (__sys_err)	/* No NULL cl_args pointer.  */
-	breq	r11, 0, L (__sys_err)	/* No NULL function pointer.  */
-
-	/* Do the system call, the kernel expects:
-	   r8: system call number
-	   r0: cl_args
-	   r1: size  */
-	mov	r0, r10
-	mov	r8, __NR_clone3
-	ARC_TRAP_INSN
-
-	cmp	r0, 0
-	beq	thread_start_clone3	/* Child returns.  */
-	blt	L (__sys_err2)
-	j	[blink]			/* Parent returns.  */
-
-L (__sys_err):
-	mov	r0, -EINVAL
-L (__sys_err2):
-	b	__syscall_error
-PSEUDO_END (__clone3)
-
-
-	.align 4
-	.type thread_start_clone3, %function
-thread_start_clone3:
-	cfi_startproc
-	/* Terminate call stack by noting ra is undefined.  */
-	cfi_undefined (blink)
-
-	/* Child jumps off to @fn with @arg as argument.  */
-	jl.d	[r11]
-	mov	r0, r12
-
-	/* exit() with result from @fn (already in r0).  */
-	mov	r8, __NR_exit
-	ARC_TRAP_INSN
-
-	/* In case it ever came back.  */
-	flag	1
-
-	cfi_endproc
-	.size thread_start_clone3, .-thread_start_clone3
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/arm/arch-syscall.h b/sysdeps/unix/sysv/linux/arm/arch-syscall.h
--- a/sysdeps/unix/sysv/linux/arm/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/arm/arch-syscall.h
@@ -2,7 +2,6 @@
 #define __NR__llseek 140
 #define __NR__newselect 142
 #define __NR__sysctl 149
-#define __NR_accept 285
 #define __NR_accept4 366
 #define __NR_access 33
 #define __NR_acct 51
@@ -19,24 +18,18 @@
 #define __NR_capget 184
 #define __NR_capset 185
 #define __NR_chdir 12
-#define __NR_chmod 15
-#define __NR_chown 182
-#define __NR_chown32 212
 #define __NR_chroot 61
 #define __NR_clock_adjtime 372
 #define __NR_clock_adjtime64 405
 #define __NR_clock_getres 264
 #define __NR_clock_getres_time64 406
 #define __NR_clock_gettime 263
-#define __NR_clock_gettime64 403
 #define __NR_clock_nanosleep 265
 #define __NR_clock_nanosleep_time64 407
 #define __NR_clock_settime 262
 #define __NR_clock_settime64 404
 #define __NR_clone 120
-#define __NR_clone3 435
 #define __NR_close 6
-#define __NR_close_range 436
 #define __NR_connect 283
 #define __NR_copy_file_range 391
 #define __NR_creat 8
@@ -48,7 +41,6 @@
 #define __NR_epoll_create1 357
 #define __NR_epoll_ctl 251
 #define __NR_epoll_pwait 346
-#define __NR_epoll_pwait2 441
 #define __NR_epoll_wait 252
 #define __NR_eventfd 351
 #define __NR_eventfd2 356
@@ -57,14 +49,12 @@
 #define __NR_exit 1
 #define __NR_exit_group 248
 #define __NR_faccessat 334
-#define __NR_faccessat2 439
 #define __NR_fallocate 352
 #define __NR_fanotify_init 367
 #define __NR_fanotify_mark 368
 #define __NR_fchdir 133
 #define __NR_fchmod 94
 #define __NR_fchmodat 333
-#define __NR_fchmodat2 452
 #define __NR_fchown 95
 #define __NR_fchown32 207
 #define __NR_fchownat 325
@@ -94,7 +84,6 @@
 #define __NR_futex_requeue 456
 #define __NR_futex_time64 422
 #define __NR_futex_wait 455
-#define __NR_futex_waitv 449
 #define __NR_futex_wake 454
 #define __NR_futimesat 326
 #define __NR_get_mempolicy 320
@@ -114,7 +103,6 @@
 #define __NR_getitimer 105
 #define __NR_getpeername 287
 #define __NR_getpgid 132
-#define __NR_getpgrp 65
 #define __NR_getpid 20
 #define __NR_getppid 64
 #define __NR_getpriority 96
@@ -156,7 +144,6 @@
 #define __NR_keyctl 311
 #define __NR_kill 37
 #define __NR_landlock_add_rule 445
-#define __NR_landlock_create_ruleset 444
 #define __NR_landlock_restrict_self 446
 #define __NR_lchown 16
 #define __NR_lchown32 198
@@ -226,7 +213,6 @@
 #define __NR_personality 136
 #define __NR_pidfd_getfd 438
 #define __NR_pidfd_open 434
-#define __NR_pidfd_send_signal 424
 #define __NR_pipe 42
 #define __NR_pipe2 359
 #define __NR_pivot_root 218
@@ -259,7 +245,6 @@
 #define __NR_readlinkat 332
 #define __NR_readv 145
 #define __NR_reboot 88
-#define __NR_recv 291
 #define __NR_recvfrom 292
 #define __NR_recvmmsg 365
 #define __NR_recvmmsg_time64 417
@@ -271,8 +256,6 @@
 #define __NR_renameat2 382
 #define __NR_request_key 310
 #define __NR_restart_syscall 0
-#define __NR_rmdir 40
-#define __NR_rseq 398
 #define __NR_rt_sigaction 174
 #define __NR_rt_sigpending 176
 #define __NR_rt_sigprocmask 175
@@ -301,7 +284,6 @@
 #define __NR_semop 298
 #define __NR_semtimedop 312
 #define __NR_semtimedop_time64 420
-#define __NR_send 289
 #define __NR_sendfile 187
 #define __NR_sendfile64 239
 #define __NR_sendmmsg 374
@@ -309,16 +291,9 @@
 #define __NR_sendto 290
 #define __NR_set_mempolicy 321
 #define __NR_set_mempolicy_home_node 450
-#define __NR_set_robust_list 338
 #define __NR_set_tid_address 256
 #define __NR_set_tls 983045
 #define __NR_setdomainname 121
-#define __NR_setfsgid 139
-#define __NR_setfsgid32 216
-#define __NR_setfsuid 138
-#define __NR_setfsuid32 215
-#define __NR_setgid 46
-#define __NR_setgid32 214
 #define __NR_setgroups 81
 #define __NR_setgroups32 206
 #define __NR_sethostname 74
@@ -328,8 +303,6 @@
 #define __NR_setpriority 97
 #define __NR_setregid 71
 #define __NR_setregid32 204
-#define __NR_setresgid 170
-#define __NR_setresgid32 210
 #define __NR_setresuid 164
 #define __NR_setresuid32 208
 #define __NR_setreuid 70
@@ -338,8 +311,6 @@
 #define __NR_setsid 66
 #define __NR_setsockopt 294
 #define __NR_settimeofday 79
-#define __NR_setuid 23
-#define __NR_setuid32 213
 #define __NR_setxattr 226
 #define __NR_shmat 305
 #define __NR_shmctl 308
@@ -361,10 +332,8 @@
 #define __NR_stat64 195
 #define __NR_statfs 99
 #define __NR_statfs64 266
-#define __NR_statx 397
 #define __NR_swapoff 115
 #define __NR_swapon 87
-#define __NR_symlink 83
 #define __NR_symlinkat 331
 #define __NR_sync 36
 #define __NR_sync_file_range2 341
diff -Narupa a/sysdeps/unix/sysv/linux/arm/clone3.S b/sysdeps/unix/sysv/linux/arm/clone3.S
--- a/sysdeps/unix/sysv/linux/arm/clone3.S
+++ b/sysdeps/unix/sysv/linux/arm/clone3.S
@@ -1,80 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/arm version.
-   Copyright (C) 2023-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-               int (*func)(void *arg), void *arg);
-
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   r0: cl_args
-   r1: size
-   r2: func
-   r3: arg  */
-
-        .text
-ENTRY(__clone3)
-	/* Sanity check args.  */
-	cmp	r0, #0
-	ite	ne
-	cmpne	r1, #0
-	moveq	r0, #-EINVAL
-	beq	PLTJMP(syscall_error)
-
-	/* Do the syscall, the kernel expects:
-	   r7: system call number:
-	   r0: cl_args
-	   r1: size  */
-	push    { r7 }
-	cfi_adjust_cfa_offset (4)
-	cfi_rel_offset (r7, 0)
-	ldr     r7, =SYS_ify(clone3)
-	swi	0x0
-	cfi_endproc
-
-	cmp	r0, #0
-	beq	1f
-	pop     {r7}
-	blt	PLTJMP(C_SYMBOL_NAME(__syscall_error))
-	RETINSTR(, lr)
-
-	cfi_startproc
-PSEUDO_END (__clone3)
-
-1:
-	.fnstart
-	.cantunwind
-	mov	r0, r3
-	mov	ip, r2
-	BLX (ip)
-
-	/* And we are done, passing the return value through r0.  */
-	ldr	r7, =SYS_ify(exit)
-	swi	0x0
-
-	.fnend
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/arm/disabled-syscall.h b/sysdeps/unix/sysv/linux/arm/disabled-syscall.h
--- a/sysdeps/unix/sysv/linux/arm/disabled-syscall.h
+++ b/sysdeps/unix/sysv/linux/arm/disabled-syscall.h
@@ -0,0 +1,31 @@
+#define __NR_accept 285
+#define __NR_chmod 15
+#define __NR_chown 182
+#define __NR_chown32 212
+#define __NR_clock_gettime64 403
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_epoll_pwait2 441
+#define __NR_faccessat2 439
+#define __NR_fchmodat2 452
+#define __NR_futex_waitv 449
+#define __NR_getpgrp 65
+#define __NR_landlock_create_ruleset 444
+#define __NR_pidfd_send_signal 424
+#define __NR_recv 291
+#define __NR_rmdir 40
+#define __NR_rseq 398
+#define __NR_send 289
+#define __NR_set_robust_list 338
+#define __NR_setfsgid 139
+#define __NR_setfsgid32 216
+#define __NR_setfsuid 138
+#define __NR_setfsuid32 215
+#define __NR_setgid 46
+#define __NR_setgid32 214
+#define __NR_setresgid 170
+#define __NR_setresgid32 210
+#define __NR_setuid 23
+#define __NR_setuid32 213
+#define __NR_statx 397
+#define __NR_symlink 83
diff -Narupa a/sysdeps/unix/sysv/linux/arm/syscall.S b/sysdeps/unix/sysv/linux/arm/syscall.S
--- a/sysdeps/unix/sysv/linux/arm/syscall.S
+++ b/sysdeps/unix/sysv/linux/arm/syscall.S
@@ -21,7 +21,7 @@
    implement syscall().  It won't work reliably with 64-bit arguments
    (but that is true on many modern platforms).  */
 
-ENTRY (syscall)
+ENTRY (syscallS)
 	mov	ip, sp
 	push	{r4, r5, r6, r7}
 	cfi_adjust_cfa_offset (16)
@@ -45,4 +45,4 @@ ENTRY (syscall)
 	it	cc
 	RETINSTR(cc, lr)
 	b	PLTJMP(syscall_error)
-PSEUDO_END (syscall)
+PSEUDO_END (syscallS)
diff -Narupa a/sysdeps/unix/sysv/linux/chmod.c b/sysdeps/unix/sysv/linux/chmod.c
--- a/sysdeps/unix/sysv/linux/chmod.c
+++ b/sysdeps/unix/sysv/linux/chmod.c
@@ -23,11 +23,7 @@
 int
 __chmod (const char *file, mode_t mode)
 {
-#ifdef __NR_chmod
-  return INLINE_SYSCALL_CALL (chmod, file, mode);
-#else
   return INLINE_SYSCALL_CALL (fchmodat, AT_FDCWD, file, mode);
-#endif
 }
 
 libc_hidden_def (__chmod)
diff -Narupa a/sysdeps/unix/sysv/linux/clock_gettime.c b/sysdeps/unix/sysv/linux/clock_gettime.c
--- a/sysdeps/unix/sysv/linux/clock_gettime.c
+++ b/sysdeps/unix/sysv/linux/clock_gettime.c
@@ -65,12 +65,6 @@ __clock_gettime64 (clockid_t clock_id, s
     }
 #endif
 
-  r = INTERNAL_SYSCALL_CALL (clock_gettime64, clock_id, tp);
-  if (r == 0)
-    return 0;
-  if (r != -ENOSYS)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
-
 #ifndef __ASSUME_TIME64_SYSCALLS
   /* Fallback code that uses 32-bit support.  */
   struct timespec tp32;
diff -Narupa a/sysdeps/unix/sysv/linux/clone-internal.c b/sysdeps/unix/sysv/linux/clone-internal.c
--- a/sysdeps/unix/sysv/linux/clone-internal.c
+++ b/sysdeps/unix/sysv/linux/clone-internal.c
@@ -72,21 +72,6 @@ int
 __clone3_internal (struct clone_args *cl_args, int (*func) (void *args),
 		   void *arg)
 {
-#ifdef HAVE_CLONE3_WRAPPER
-# if __ASSUME_CLONE3
-  return __clone3 (cl_args, sizeof (*cl_args), func, arg);
-# else
-  static int clone3_supported = 1;
-  if (atomic_load_relaxed (&clone3_supported) == 1)
-    {
-      int ret = __clone3 (cl_args, sizeof (*cl_args), func, arg);
-      if (ret != -1 || errno != ENOSYS)
-	return ret;
-
-      atomic_store_relaxed (&clone3_supported, 0);
-    }
-# endif
-#endif
   __set_errno (ENOSYS);
   return -1;
 }
@@ -95,17 +80,6 @@ int
 __clone_internal (struct clone_args *cl_args,
 		  int (*func) (void *arg), void *arg)
 {
-#ifdef HAVE_CLONE3_WRAPPER
-  int saved_errno = errno;
-  int ret = __clone3_internal (cl_args, func, arg);
-  if (ret != -1 || errno != ENOSYS)
-    return ret;
-
-  /* NB: Restore errno since errno may be checked against non-zero
-     return value.  */
-  __set_errno (saved_errno);
-#endif
-
   return __clone_internal_fallback (cl_args, func, arg);
 }
 
diff -Narupa a/sysdeps/unix/sysv/linux/epoll_pwait2.c b/sysdeps/unix/sysv/linux/epoll_pwait2.c
--- a/sysdeps/unix/sysv/linux/epoll_pwait2.c
+++ b/sysdeps/unix/sysv/linux/epoll_pwait2.c
@@ -16,15 +16,26 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
 #include <sys/epoll.h>
-#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+#define MSEC_PER_SEC 1000L
+#define NSEC_PER_MSEC 1000000L
 
 int
 __epoll_pwait2_time64 (int fd, struct epoll_event *ev, int maxev,
 		       const struct __timespec64 *tmo, const sigset_t *s)
 {
-  /* The syscall only supports 64-bit time_t.  */
-  return SYSCALL_CANCEL (epoll_pwait2, fd, ev, maxev, tmo, s, __NSIG_BYTES);
+  long timeout = tmo->tv_sec * MSEC_PER_SEC;
+  if (tmo->tv_nsec > 0) {
+    timeout += tmo->tv_nsec / NSEC_PER_MSEC;
+    if (tmo->tv_nsec % NSEC_PER_MSEC > 0)
+      timeout += 1;
+  }
+  return epoll_pwait (fd, ev, maxev, timeout, s);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__epoll_pwait2_time64)
diff -Narupa a/sysdeps/unix/sysv/linux/faccessat.c b/sysdeps/unix/sysv/linux/faccessat.c
--- a/sysdeps/unix/sysv/linux/faccessat.c
+++ b/sysdeps/unix/sysv/linux/faccessat.c
@@ -26,16 +26,6 @@
 int
 __faccessat (int fd, const char *file, int mode, int flag)
 {
-  int ret = INLINE_SYSCALL_CALL (faccessat2, fd, file, mode, flag);
-#if __ASSUME_FACCESSAT2
-  return ret;
-#else
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-
-  if (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS))
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
   if ((flag == 0 || ((flag & ~AT_EACCESS) == 0 && ! __libc_enable_secure)))
     return INLINE_SYSCALL (faccessat, 3, fd, file, mode);
 
@@ -71,6 +61,5 @@ __faccessat (int fd, const char *file, i
     return 0;
 
   return INLINE_SYSCALL_ERROR_RETURN_VALUE (EACCES);
-#endif /* !__ASSUME_FACCESSAT2 */
 }
 weak_alias (__faccessat, faccessat)
diff -Narupa a/sysdeps/unix/sysv/linux/fake-syscall.h b/sysdeps/unix/sysv/linux/fake-syscall.h
--- a/sysdeps/unix/sysv/linux/fake-syscall.h
+++ b/sysdeps/unix/sysv/linux/fake-syscall.h
@@ -0,0 +1,33 @@
+#ifndef _FAKE_SYSCALL
+#define _FAKE_SYSCALL
+
+#include <arch-syscall.h>
+#include <disabled-syscall.h>
+
+extern int close_range (unsigned int __fd, unsigned int __max_fd, int __flags) __THROW;
+
+struct FakeSyscall {
+	int id;
+	long int (*func)(long int,
+			 long int,
+			 long int,
+			 long int,
+			 long int,
+			 long int);
+};
+
+long int JustReturnZero() {
+	return 0;
+}
+
+static struct FakeSyscall FakeSyscalls[] = {
+	{ __NR_close_range, close_range },
+	{ __NR_mbind, JustReturnZero },
+	{ __NR_get_mempolicy, JustReturnZero },
+	{ __NR_set_mempolicy, JustReturnZero },
+	{ 1008, JustReturnZero }, // for some reason used in julia
+};
+
+#define CountFakeSyscalls (sizeof(FakeSyscalls) / sizeof(FakeSyscalls[0]))
+
+#endif //_FAKE_SYSCALL
diff -Narupa a/sysdeps/unix/sysv/linux/fchmodat.c b/sysdeps/unix/sysv/linux/fchmodat.c
--- a/sysdeps/unix/sysv/linux/fchmodat.c
+++ b/sysdeps/unix/sysv/linux/fchmodat.c
@@ -26,7 +26,6 @@
 #include <sysdep.h>
 #include <unistd.h>
 
-#if !__ASSUME_FCHMODAT2
 static int
 fchmodat_fallback (int fd, const char *file, mode_t mode, int flag)
 {
@@ -85,21 +84,13 @@ fchmodat_fallback (int fd, const char *f
   __close_nocancel (pathfd);
   return ret;
 }
-#endif
 
 int
 fchmodat (int fd, const char *file, mode_t mode, int flag)
 {
-#if __ASSUME_FCHMODAT2
-  return INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);
-#else
   if (flag == 0)
     return INLINE_SYSCALL_CALL (fchmodat, fd, file, mode);
 
-  int r = INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);
-  if (r != 0 && errno == ENOSYS)
-    return fchmodat_fallback (fd, file, mode, flag);
-  return r;
-#endif
+  return fchmodat_fallback (fd, file, mode, flag);
 }
 libc_hidden_def (fchmodat)
diff -Narupa a/sysdeps/unix/sysv/linux/fstatat64.c b/sysdeps/unix/sysv/linux/fstatat64.c
--- a/sysdeps/unix/sysv/linux/fstatat64.c
+++ b/sysdeps/unix/sysv/linux/fstatat64.c
@@ -38,43 +38,6 @@ _Static_assert (sizeof (__blkcnt_t) == s
                 "__blkcnt_t and __blkcnt64_t must match");
 #endif
 
-#if FSTATAT_USE_STATX
-
-static inline int
-fstatat64_time64_statx (int fd, const char *file, struct __stat64_t64 *buf,
-			int flag)
-{
-  /* 32-bit kABI with default 64-bit time_t, e.g. arc, riscv32.   Also
-     64-bit time_t support is done through statx syscall.  */
-  struct statx tmp;
-  int r = INTERNAL_SYSCALL_CALL (statx, fd, file, AT_NO_AUTOMOUNT | flag,
-				 STATX_BASIC_STATS, &tmp);
-  if (r != 0)
-    return r;
-
-  *buf = (struct __stat64_t64) {
-    .st_dev = __gnu_dev_makedev (tmp.stx_dev_major, tmp.stx_dev_minor),
-    .st_rdev = __gnu_dev_makedev (tmp.stx_rdev_major, tmp.stx_rdev_minor),
-    .st_ino = tmp.stx_ino,
-    .st_mode = tmp.stx_mode,
-    .st_nlink = tmp.stx_nlink,
-    .st_uid = tmp.stx_uid,
-    .st_gid = tmp.stx_gid,
-    .st_atime = tmp.stx_atime.tv_sec,
-    .st_atim.tv_nsec = tmp.stx_atime.tv_nsec,
-    .st_mtime = tmp.stx_mtime.tv_sec,
-    .st_mtim.tv_nsec = tmp.stx_mtime.tv_nsec,
-    .st_ctime = tmp.stx_ctime.tv_sec,
-    .st_ctim.tv_nsec = tmp.stx_ctime.tv_nsec,
-    .st_size = tmp.stx_size,
-    .st_blocks = tmp.stx_blocks,
-    .st_blksize = tmp.stx_blksize,
-  };
-
-  return r;
-}
-#endif
-
 /* Only statx supports 64-bit timestamps for 32-bit architectures with
    __ASSUME_STATX, so there is no point in building the fallback.  */
 #if !FSTATAT_USE_STATX || (FSTATAT_USE_STATX && !defined __ASSUME_STATX)
@@ -147,11 +110,7 @@ __fstatat64_time64 (int fd, const char *
   int r;
 
 #if FSTATAT_USE_STATX
-  r = fstatat64_time64_statx (fd, file, buf, flag);
-# ifndef __ASSUME_STATX
-  if (r == -ENOSYS)
-    r = fstatat64_time64_stat (fd, file, buf, flag);
-# endif
+  r = fstatat64_time64_stat (fd, file, buf, flag);
 #else
   r = fstatat64_time64_stat (fd, file, buf, flag);
 #endif
diff -Narupa a/sysdeps/unix/sysv/linux/ftruncate.c b/sysdeps/unix/sysv/linux/ftruncate.c
--- a/sysdeps/unix/sysv/linux/ftruncate.c
+++ b/sysdeps/unix/sysv/linux/ftruncate.c
@@ -24,12 +24,8 @@
 int
 __ftruncate (int fd, off_t length)
 {
-# ifndef __NR_ftruncate
   return INLINE_SYSCALL_CALL (ftruncate64, fd,
 			      __ALIGNMENT_ARG SYSCALL_LL (length));
-# else
-  return INLINE_SYSCALL_CALL (ftruncate, fd, length);
-# endif
 }
 weak_alias (__ftruncate, ftruncate)
 #endif
diff -Narupa a/sysdeps/unix/sysv/linux/fxstat64.c b/sysdeps/unix/sysv/linux/fxstat64.c
--- a/sysdeps/unix/sysv/linux/fxstat64.c
+++ b/sysdeps/unix/sysv/linux/fxstat64.c
@@ -50,14 +50,6 @@ ___fxstat64 (int vers, int fd, struct st
   if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX)
     return INLINE_SYSCALL_CALL (fstat, fd, buf);
   return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-# else
-  /* New 32-bit kABIs with only 64-bit time_t support, e.g. arc, riscv32.  */
-  struct statx tmp;
-  int r = INLINE_SYSCALL_CALL (statx, fd, "", AT_EMPTY_PATH,
-			       STATX_BASIC_STATS, &tmp);
-  if (r == 0)
-    __cp_stat64_statx (buf, &tmp);
-  return r;
 # endif
 #else
   /* All kABIs with non-LFS support, e.g. arm, csky, i386, hppa, m68k,
diff -Narupa a/sysdeps/unix/sysv/linux/fxstatat64.c b/sysdeps/unix/sysv/linux/fxstatat64.c
--- a/sysdeps/unix/sysv/linux/fxstatat64.c
+++ b/sysdeps/unix/sysv/linux/fxstatat64.c
@@ -44,17 +44,6 @@ __fxstatat64 (int vers, int fd, const ch
   struct stat64 st64;
   int r = INLINE_SYSCALL_CALL (fstatat64, fd, file, &st64, flag);
   return r ?: __xstat32_conv (vers, &st64, (struct stat *) st);
-# else
-  /* New 32-bit kABIs with only 64-bit time_t support, e.g. arc, riscv32.  */
-  if (vers == _STAT_VER_KERNEL)
-    {
-      struct statx tmp;
-      int r = INLINE_SYSCALL_CALL (statx, fd, file, AT_NO_AUTOMOUNT | flag,
-				   STATX_BASIC_STATS, &tmp);
-      if (r == 0)
-	__cp_stat64_statx (st, &tmp);
-      return r;
-    }
 # endif
 #else
   /* All kABIs with non-LFS support, e.g. arm, csky, i386, hppa, m68k,
diff -Narupa a/sysdeps/unix/sysv/linux/gentempfd.c b/sysdeps/unix/sysv/linux/gentempfd.c
--- a/sysdeps/unix/sysv/linux/gentempfd.c
+++ b/sysdeps/unix/sysv/linux/gentempfd.c
@@ -26,8 +26,8 @@ __gen_tempfd (int flags)
 {
   int fd = __open (P_tmpdir, O_RDWR | O_TMPFILE | O_EXCL | flags,
 		   S_IRUSR | S_IWUSR);
-  if (fd < 0 && errno == ENOENT && strcmp (P_tmpdir, "/tmp") != 0)
-    fd = __open ("/tmp", O_RDWR | O_TMPFILE | O_EXCL | flags,
+  if (fd < 0 && errno == ENOENT && strcmp (P_tmpdir, "/data/data/com.termux/files/usr/tmp") != 0)
+    fd = __open ("/data/data/com.termux/files/usr/tmp", O_RDWR | O_TMPFILE | O_EXCL | flags,
 		 S_IRUSR | S_IWUSR);
 
   return fd;
diff -Narupa a/sysdeps/unix/sysv/linux/i386/arch-syscall.h b/sysdeps/unix/sysv/linux/i386/arch-syscall.h
--- a/sysdeps/unix/sysv/linux/i386/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/i386/arch-syscall.h
@@ -19,24 +19,18 @@
 #define __NR_capget 184
 #define __NR_capset 185
 #define __NR_chdir 12
-#define __NR_chmod 15
-#define __NR_chown 182
-#define __NR_chown32 212
 #define __NR_chroot 61
 #define __NR_clock_adjtime 343
 #define __NR_clock_adjtime64 405
 #define __NR_clock_getres 266
 #define __NR_clock_getres_time64 406
 #define __NR_clock_gettime 265
-#define __NR_clock_gettime64 403
 #define __NR_clock_nanosleep 267
 #define __NR_clock_nanosleep_time64 407
 #define __NR_clock_settime 264
 #define __NR_clock_settime64 404
 #define __NR_clone 120
-#define __NR_clone3 435
 #define __NR_close 6
-#define __NR_close_range 436
 #define __NR_connect 362
 #define __NR_copy_file_range 377
 #define __NR_creat 8
@@ -49,7 +43,6 @@
 #define __NR_epoll_create1 329
 #define __NR_epoll_ctl 255
 #define __NR_epoll_pwait 319
-#define __NR_epoll_pwait2 441
 #define __NR_epoll_wait 256
 #define __NR_eventfd 323
 #define __NR_eventfd2 328
@@ -58,7 +51,6 @@
 #define __NR_exit 1
 #define __NR_exit_group 252
 #define __NR_faccessat 307
-#define __NR_faccessat2 439
 #define __NR_fadvise64 250
 #define __NR_fadvise64_64 272
 #define __NR_fallocate 324
@@ -67,7 +59,6 @@
 #define __NR_fchdir 133
 #define __NR_fchmod 94
 #define __NR_fchmodat 306
-#define __NR_fchmodat2 452
 #define __NR_fchown 95
 #define __NR_fchown32 207
 #define __NR_fchownat 298
@@ -98,7 +89,6 @@
 #define __NR_futex_requeue 456
 #define __NR_futex_time64 422
 #define __NR_futex_wait 455
-#define __NR_futex_waitv 449
 #define __NR_futex_wake 454
 #define __NR_futimesat 299
 #define __NR_get_kernel_syms 130
@@ -120,7 +110,6 @@
 #define __NR_getitimer 105
 #define __NR_getpeername 368
 #define __NR_getpgid 132
-#define __NR_getpgrp 65
 #define __NR_getpid 20
 #define __NR_getpmsg 188
 #define __NR_getppid 64
@@ -168,7 +157,6 @@
 #define __NR_keyctl 288
 #define __NR_kill 37
 #define __NR_landlock_add_rule 445
-#define __NR_landlock_create_ruleset 444
 #define __NR_landlock_restrict_self 446
 #define __NR_lchown 16
 #define __NR_lchown32 198
@@ -245,7 +233,6 @@
 #define __NR_personality 136
 #define __NR_pidfd_getfd 438
 #define __NR_pidfd_open 434
-#define __NR_pidfd_send_signal 424
 #define __NR_pipe 42
 #define __NR_pipe2 331
 #define __NR_pivot_root 217
@@ -294,8 +281,6 @@
 #define __NR_renameat2 353
 #define __NR_request_key 287
 #define __NR_restart_syscall 0
-#define __NR_rmdir 40
-#define __NR_rseq 386
 #define __NR_rt_sigaction 174
 #define __NR_rt_sigpending 176
 #define __NR_rt_sigprocmask 175
@@ -330,16 +315,9 @@
 #define __NR_sendto 369
 #define __NR_set_mempolicy 276
 #define __NR_set_mempolicy_home_node 450
-#define __NR_set_robust_list 311
 #define __NR_set_thread_area 243
 #define __NR_set_tid_address 258
 #define __NR_setdomainname 121
-#define __NR_setfsgid 139
-#define __NR_setfsgid32 216
-#define __NR_setfsuid 138
-#define __NR_setfsuid32 215
-#define __NR_setgid 46
-#define __NR_setgid32 214
 #define __NR_setgroups 81
 #define __NR_setgroups32 206
 #define __NR_sethostname 74
@@ -349,8 +327,6 @@
 #define __NR_setpriority 97
 #define __NR_setregid 71
 #define __NR_setregid32 204
-#define __NR_setresgid 170
-#define __NR_setresgid32 210
 #define __NR_setresuid 164
 #define __NR_setresuid32 208
 #define __NR_setreuid 70
@@ -359,8 +335,6 @@
 #define __NR_setsid 66
 #define __NR_setsockopt 366
 #define __NR_settimeofday 79
-#define __NR_setuid 23
-#define __NR_setuid32 213
 #define __NR_setxattr 226
 #define __NR_sgetmask 68
 #define __NR_shmat 397
@@ -386,12 +360,10 @@
 #define __NR_stat64 195
 #define __NR_statfs 99
 #define __NR_statfs64 268
-#define __NR_statx 383
 #define __NR_stime 25
 #define __NR_stty 31
 #define __NR_swapoff 115
 #define __NR_swapon 87
-#define __NR_symlink 83
 #define __NR_symlinkat 304
 #define __NR_sync 36
 #define __NR_sync_file_range 314
diff -Narupa a/sysdeps/unix/sysv/linux/i386/clone3.S b/sysdeps/unix/sysv/linux/i386/clone3.S
--- a/sysdeps/unix/sysv/linux/i386/clone3.S
+++ b/sysdeps/unix/sysv/linux/i386/clone3.S
@@ -1,123 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/i386 version.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* clone3() is even more special than fork() as it mucks with stacks
-   and invokes a function in the right context after its all over.  */
-
-#include <sysdep.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-	       int (*func)(void *arg), void *arg);
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed on stack from userland:
-   16(%esp)	arg
-   12(%esp)	func
-    8(%esp)	size
-    4(%esp)	cl_args
-     (%esp)	Return address
-
-   The kernel expects:
-   eax:		system call number
-   ebx:		cl_args
-   ecx:		size
- */
-
-#define CL_ARGS	4
-#define SIZE	8
-#define FUNC	12
-#define ARG	16
-
-        .text
-ENTRY (__clone3)
-	/* Sanity check arguments.  */
-	movl	$-EINVAL, %eax
-	movl	CL_ARGS(%esp), %ecx	/* No NULL cl_args pointer.  */
-	testl	%ecx, %ecx
-	jz	SYSCALL_ERROR_LABEL
-	/* Save the function pointer in EDX which is preserved by the
-	   system call.  */
-	movl	FUNC(%esp), %edx	/* No NULL function pointer.  */
-	testl	%edx, %edx
-	jz	SYSCALL_ERROR_LABEL
-
-	/* Save EBX and ESI.  */
-	pushl	%ebx
-	cfi_adjust_cfa_offset (4)
-	pushl	%esi
-	cfi_adjust_cfa_offset (4)
-
-	/* Save the function argument in ESI which is preserved by the
-	   system call.  */
-	movl	(ARG + 8)(%esp), %esi
-
-	/* Put cl_args in EBX.  */
-	movl	%ecx, %ebx
-
-	/* Put size in ECX.  */
-	movl	(SIZE + 8)(%esp), %ecx
-
-	/* Do the system call.  */
-	movl	$SYS_ify(clone3), %eax
-
-	/* End FDE now, because in the child the unwind info will be
-	   wrong.  */
-	cfi_endproc
-
-	int	$0x80
-	test	%eax, %eax
-	/* No need to restore EBX and ESI in child.  */
-	jz	L(thread_start)
-
-	/* Restore EBX and ESI in parent.  */
-	pop	%esi
-	pop	%ebx
-	jl	SYSCALL_ERROR_LABEL
-
-	ret
-
-L(thread_start):
-	cfi_startproc
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (eip)
-	xorl	%ebp, %ebp	/* Terminate the stack frame.  */
-
-	/* Align stack to 16 bytes per the i386 psABI.  */
-	andl	$-16, %esp
-
-	/* The PUSH below will decrement stack pointer by 4 bytes.  */
-	subl	$12, %esp
-
-	/* Set up the argument for the function call.  */
-	pushl	%esi		/* Argument.  */
-	cfi_adjust_cfa_offset (4)
-	call	*%edx		/* Call function.  */
-
-	/* Call exit with return value from function call. */
-	movl	%eax, %ebx
-	movl	$SYS_ify(exit), %eax
-	ENTER_KERNEL
-	cfi_endproc
-
-	cfi_startproc
-PSEUDO_END (__clone3)
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/i386/disabled-syscall.h b/sysdeps/unix/sysv/linux/i386/disabled-syscall.h
--- a/sysdeps/unix/sysv/linux/i386/disabled-syscall.h
+++ b/sysdeps/unix/sysv/linux/i386/disabled-syscall.h
@@ -0,0 +1,28 @@
+#define __NR_chmod 15
+#define __NR_chown 182
+#define __NR_chown32 212
+#define __NR_clock_gettime64 403
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_epoll_pwait2 441
+#define __NR_faccessat2 439
+#define __NR_fchmodat2 452
+#define __NR_futex_waitv 449
+#define __NR_getpgrp 65
+#define __NR_landlock_create_ruleset 444
+#define __NR_pidfd_send_signal 424
+#define __NR_rmdir 40
+#define __NR_rseq 386
+#define __NR_set_robust_list 311
+#define __NR_setfsgid 139
+#define __NR_setfsgid32 216
+#define __NR_setfsuid 138
+#define __NR_setfsuid32 215
+#define __NR_setgid 46
+#define __NR_setgid32 214
+#define __NR_setresgid 170
+#define __NR_setresgid32 210
+#define __NR_setuid 23
+#define __NR_setuid32 213
+#define __NR_statx 383
+#define __NR_symlink 83
diff -Narupa a/sysdeps/unix/sysv/linux/i386/syscall.S b/sysdeps/unix/sysv/linux/i386/syscall.S
--- a/sysdeps/unix/sysv/linux/i386/syscall.S
+++ b/sysdeps/unix/sysv/linux/i386/syscall.S
@@ -21,7 +21,7 @@
    more information about the value -4095 used below.*/
 
 	.text
-ENTRY (syscall)
+ENTRY (syscallS)
 
 	PUSHARGS_6		/* Save register contents.  */
 	_DOARGS_6(44)		/* Load arguments.  */
@@ -32,4 +32,4 @@ ENTRY (syscall)
 	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 	ret			/* Return to caller.  */
 
-PSEUDO_END (syscall)
+PSEUDO_END (syscallS)
diff -Narupa a/sysdeps/unix/sysv/linux/i386/syscalls.list b/sysdeps/unix/sysv/linux/i386/syscalls.list
--- a/sysdeps/unix/sysv/linux/i386/syscalls.list
+++ b/sysdeps/unix/sysv/linux/i386/syscalls.list
@@ -1,9 +1,5 @@
 # File name	Caller	Syscall name	Args	Strong name	Weak names
 
-chown		-	chown32		i:sii	__chown		chown@@GLIBC_2.1
-lchown		-	lchown32	i:sii	__lchown	lchown@@GLIBC_2.0 chown@GLIBC_2.0
-fchown		-	fchown32	i:iii	__fchown	fchown
-
 getegid		-	getegid32	Ei:	__getegid	getegid
 geteuid		-	geteuid32	Ei:	__geteuid	geteuid
 getgid		-	getgid32	Ei:	__getgid	getgid
diff -Narupa a/sysdeps/unix/sysv/linux/local-setxid.h b/sysdeps/unix/sysv/linux/local-setxid.h
--- a/sysdeps/unix/sysv/linux/local-setxid.h
+++ b/sysdeps/unix/sysv/linux/local-setxid.h
@@ -1,6 +1,7 @@
 /* SETxID functions which only have to change the local thread and
    none of the possible other threads.  */
 #include <sysdep.h>
+#include <unistd.h>
 
 #ifdef __NR_setresuid32
 # define local_seteuid(id) INLINE_SYSCALL (setresuid32, 3, -1, id, -1)
@@ -9,8 +10,4 @@
 #endif
 
 
-#ifdef __NR_setresgid32
-# define local_setegid(id) INLINE_SYSCALL (setresgid32, 3, -1, id, -1)
-#else
-# define local_setegid(id) INLINE_SYSCALL (setresgid, 3, -1, id, -1)
-#endif
+#define local_setegid(id) __setresgid (-1, id, -1)
diff -Narupa a/sysdeps/unix/sysv/linux/loongarch/clone3.S b/sysdeps/unix/sysv/linux/loongarch/clone3.S
--- a/sysdeps/unix/sysv/linux/loongarch/clone3.S
+++ b/sysdeps/unix/sysv/linux/loongarch/clone3.S
@@ -1,83 +0,0 @@
-/* The clone3 syscall wrapper.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* clone3() is even more special than fork() as it mucks with stacks
-   and invokes a function in the right context after its all over.  */
-
-#include <sys/asm.h>
-#include <sysdep.h>
-#define _ERRNO_H  1
-#include <bits/errno.h>
-#include <tls.h>
-#include "tcb-offsets.h"
-
-/* int clone3(struct clone_args *cl_args, size_t size,
-   int (*func)(void *arg), void *arg); */
-
-ENTRY (__clone3)
-
-	/* Sanity check arguments.  */
-	beqz		a0, L (invalid)	/* No NULL cl_args pointer.  */
-	beqz		a2, L (invalid)	/* No NULL function pointer.  */
-
-	/* Do the system call.  */
-	LI		a7, __NR_clone3
-	syscall		0
-
-	blt		a0, zero ,L (error)
-	beqz		a0, L (thread_start3)
-
-	/* Successful return from the parent.  */
-	ret
-
-L (invalid):
-	LI		a0, -EINVAL
-
-	/* Something bad happened -- no child created.  */
-L (error):
-	b		__syscall_error
-
-END (__clone3)
-
-/* Load up the arguments to the function.  Put this block of code in
-   its own function so that we can terminate the stack trace with our
-   debug info.  */
-ENTRY (__thread_start3)
-L (thread_start3):
-
-/* Terminate call stack by noting ra is undefined.  Use a dummy
-   .cfi_label to force starting the FDE.  */
-	.cfi_label .Ldummy
-	cfi_undefined (1)
-
-	/* Align stack to 16.  */
-	BSTRINS		sp, zero, 3, 0
-
-	/* Set up arguments for the function call.  */
-	move		a0, a3		/* Argument.  */
-	jirl		ra, a2, 0	/* Call function.  */
-
-	/* Call exit with the function's return value.  */
-	LI		a7, __NR_exit
-	syscall		0
-
-	END (__thread_start3)
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/lxstat64.c b/sysdeps/unix/sysv/linux/lxstat64.c
--- a/sysdeps/unix/sysv/linux/lxstat64.c
+++ b/sysdeps/unix/sysv/linux/lxstat64.c
@@ -53,18 +53,6 @@ ___lxstat64 (int vers, const char *name,
   if (vers == _STAT_VER_KERNEL)
     return INLINE_SYSCALL_CALL (newfstatat, AT_FDCWD, name, buf,
 				AT_SYMLINK_NOFOLLOW);
-# else
-  /* New 32-bit kABIs with only 64-bit time_t support, e.g. arc, riscv32.  */
-  if (vers == _STAT_VER_KERNEL)
-    {
-      struct statx tmp;
-      int r = INLINE_SYSCALL_CALL (statx, AT_FDCWD, name,
-				   AT_NO_AUTOMOUNT | AT_SYMLINK_NOFOLLOW,
-				   STATX_BASIC_STATS, &tmp);
-      if (r == 0)
-	__cp_stat64_statx (buf, &tmp);
-      return r;
-     }
 # endif
 #else
 # if STAT_IS_KERNEL_STAT
diff -Narupa a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -95,8 +95,6 @@ sysdep_routines += \
   process_vm_writev \
   pselect32 \
   readahead \
-  setfsgid \
-  setfsuid \
   setvmaname \
   signalfd \
   splice \
diff -Narupa a/sysdeps/unix/sysv/linux/mips/clone3.S b/sysdeps/unix/sysv/linux/mips/clone3.S
--- a/sysdeps/unix/sysv/linux/mips/clone3.S
+++ b/sysdeps/unix/sysv/linux/mips/clone3.S
@@ -1,139 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/mips version.
-   Copyright (C) 2023-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sys/asm.h>
-#include <sysdep.h>
-#define _ERRNO_H        1
-#include <bits/errno.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-               int (*func)(void *arg), void *arg);
-
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   a0/$4: cl_args
-   a1/$5: size
-   a2/$6: func
-   a3/$7: arg  */
-
-	.text
-	.set		nomips16
-#if _MIPS_SIM == _ABIO32
-# define EXTRA_LOCALS 1
-#else
-# define EXTRA_LOCALS 0
-#endif
-#define FRAMESZ ((NARGSAVE*SZREG)+ALSZ)&ALMASK
-GPOFF= FRAMESZ-(1*SZREG)
-NESTED(__clone3, SZREG, sp)
-#ifdef __PIC__
-	SETUP_GP
-#endif
-#if FRAMESZ
-	PTR_SUBU sp, FRAMESZ
-	cfi_adjust_cfa_offset (FRAMESZ)
-#endif
-	SETUP_GP64_STACK (GPOFF, __clone3)
-#ifdef __PIC__
-	SAVE_GP (GPOFF)
-#endif
-#ifdef PROF
-	.set	noat
-	move	$1,ra
-	jal	_mcount
-	.set	at
-#endif
-
-	/* Sanity check args.  */
-	li	v0, EINVAL
-	beqz	a0, L(error)	/* No NULL cl_args pointer.  */
-	beqz	a2, L(error)	/* No NULL function pointer.  */
-
-	move	$8, a3		/* a3 is set to 0/1 for syscall success/error
-				   while a4/$8 is returned unmodified.  */
-
-	/* Do the system call, the kernel expects:
-	   v0: system call number
-	   a0: cl_args
-	   a1: size  */
-	li		v0, __NR_clone3
-	cfi_endproc
-	syscall
-
-	bnez		a3, L(error)
-	beqz		v0, L(thread_start_clone3)
-
-	/* Successful return from the parent */
-	cfi_startproc
-#if FRAMESZ
-	cfi_adjust_cfa_offset (FRAMESZ)
-#endif
-	SETUP_GP64_STACK_CFI (GPOFF)
-	cfi_remember_state
-	RESTORE_GP64_STACK
-#if FRAMESZ
-	PTR_ADDU	sp, FRAMESZ
-	cfi_adjust_cfa_offset (-FRAMESZ)
-#endif
-	ret
-
-L(error):
-	cfi_restore_state
-#ifdef __PIC__
-	PTR_LA		t9, __syscall_error
-	RESTORE_GP64_STACK
-	PTR_ADDU	sp, FRAMESZ
-	cfi_adjust_cfa_offset (-FRAMESZ)
-	jr		t9
-#else
-	RESTORE_GP64_STACK
-	PTR_ADDU	sp, FRAMESZ
-	cfi_adjust_cfa_offset (-FRAMESZ)
-	j		__syscall_error
-#endif
-END (__clone3)
-
-/* Load up the arguments to the function.  Put this block of code in
-   its own function so that we can terminate the stack trace with our
-   debug info.  */
-
-ENTRY(__thread_start_clone3)
-L(thread_start_clone3):
-	cfi_undefined ($31)
-	/* cp is already loaded.  */
-	SAVE_GP (GPOFF)
-	/* The stackframe has been created on entry of clone3.  */
-
-	/* Restore the arg for user's function.  */
-	move		t9, a2		/* Function pointer.  */
-	move		a0, $8		/* Argument pointer.  */
-
-	/* Call the user's function.  */
-	jal		t9
-
-	move		a0, v0
-	li		v0, __NR_exit
-	syscall
-END(__thread_start_clone3)
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/mprotect.c b/sysdeps/unix/sysv/linux/mprotect.c
--- a/sysdeps/unix/sysv/linux/mprotect.c
+++ b/sysdeps/unix/sysv/linux/mprotect.c
@@ -0,0 +1,103 @@
+/* - Fix for Termux
+   If you run mprotect with the PROT_EXEC flag,
+   then the error "Permission denied" is displayed.
+
+   Cause: https://github.com/termux/proot/commit/89bfa991cb3cb7fc78099d06d0f7e7c840cb62d1
+   Issue: https://github.com/termux-pacman/glibc-packages/issues/49
+   Solution: https://stackoverflow.com/questions/59303617/c-mprotect-for-read-write-and-execute
+*/
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <string.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <not-cancel.h>
+
+#ifdef SHARED
+# define GLOBAL_READ_SIZE 1024
+
+/* - String To Unsigned Long Int
+   There are two chairs - one is called "strtoul", the other "stuli"...
+*/
+unsigned long int __stuli(char *value) {
+	unsigned long int val, res = 0;
+	int len = strlen(value);
+
+	for (int i=0; i<len; i++) {
+		val = value[len-1-i]-'0';
+		if (val == 0)
+			continue;
+		else if (val > 9)
+			val = value[len-1-i]-'W';
+		for (int j=0; j<i; j++)
+			val *= 16;
+		res += val;
+	}
+
+	return res;
+}
+
+static int __is_mmaped(void *addr) {
+	char buff[GLOBAL_READ_SIZE];
+	char *buff2 = "";
+	char *cont = "";
+	int res = 0;
+	int strlc, strlb;
+	memset(buff, 0, sizeof(buff));
+	int map = __open_nocancel("/proc/self/maps", O_RDONLY|O_CLOEXEC);
+	if (map >= 0) {
+		while (__read_nocancel(map, buff, GLOBAL_READ_SIZE) > 0) {
+			buff[GLOBAL_READ_SIZE] = '\0';
+			strlc = strlen(cont);
+			if (strlc > 0) {
+				buff2 = malloc(sizeof(char)*strlc);
+				memcpy(buff2, cont, strlc);
+			}
+			cont = malloc(sizeof(char)*(strlc+strlen(buff)));
+			memset(cont, 0, sizeof(cont));
+			strlb = strlen(buff2);
+			if (strlb > 0)
+				memcpy(cont, buff2, strlb);
+			__strncat(cont, buff, GLOBAL_READ_SIZE);
+			memset(buff, 0, sizeof(buff));
+		}
+		char *saveptr;
+		while ((buff2 = strtok_r(cont, "\n", &cont)))
+			if (__stuli(strtok_r(buff2, "-", &saveptr)) == (unsigned long int)addr) {
+				res = 1;
+				break;
+		}
+	}
+	__close_nocancel_nostatus(map);
+	return res;
+}
+#endif
+
+int __mprotect(void *addr, size_t len, int prot) {
+	int res = INLINE_SYSCALL_CALL(mprotect, addr, len, prot);
+#ifdef SHARED
+	if (res == -1 && errno == EACCES && prot & PROT_EXEC && !__is_mmaped(addr)) {
+		size_t saddr = strlen(addr)+1;
+		void *caddr;
+		int mmap_flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED;
+		if (prot & PROT_GROWSDOWN)
+			mmap_flags |= MAP_GROWSDOWN;
+		if (saddr > 1) {
+			caddr = malloc(saddr);
+			memcpy(caddr, addr, saddr);
+		}
+		free(addr);
+		addr = mmap(addr, len, PROT_READ|PROT_WRITE|PROT_EXEC, mmap_flags, -1, 0);
+		if (saddr > 1)
+			memcpy(addr, caddr, saddr);
+		return INLINE_SYSCALL_CALL(mprotect, addr, len, prot);
+	}
+#endif
+	return res;
+}
+
+libc_hidden_def(__mprotect)
+weak_alias(__mprotect, mprotect)
diff -Narupa a/sysdeps/unix/sysv/linux/paths.h b/sysdeps/unix/sysv/linux/paths.h
--- a/sysdeps/unix/sysv/linux/paths.h
+++ b/sysdeps/unix/sysv/linux/paths.h
@@ -33,43 +33,43 @@
 #define	_PATHS_H_
 
 /* Default search path. */
-#define	_PATH_DEFPATH	"/usr/bin:/bin"
+#define	_PATH_DEFPATH	"/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin:/system/bin"
 /* All standard utilities path. */
 #define	_PATH_STDPATH \
-	"/usr/bin:/bin:/usr/sbin:/sbin"
+	"/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin:/system/bin"
 
-#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_BSHELL	"/data/data/com.termux/files/usr/bin/sh"
 #define	_PATH_CONSOLE	"/dev/console"
-#define	_PATH_CSHELL	"/bin/csh"
-#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_CSHELL	"/data/data/com.termux/files/usr/bin/csh"
+#define	_PATH_DEVDB	"/data/data/com.termux/files/usr/var/run/dev.db"
 #define	_PATH_DEVNULL	"/dev/null"
 #define	_PATH_DRUM	"/dev/drum"
-#define	_PATH_GSHADOW	"/etc/gshadow"
+#define	_PATH_GSHADOW	"/data/data/com.termux/files/usr/etc/gshadow"
 #define	_PATH_KLOG	"/proc/kmsg"
 #define	_PATH_KMEM	"/dev/kmem"
-#define	_PATH_LASTLOG	"/var/log/lastlog"
-#define	_PATH_MAILDIR	"/var/mail"
-#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_LASTLOG	"/data/data/com.termux/files/usr/var/log/lastlog"
+#define	_PATH_MAILDIR	"/data/data/com.termux/files/usr/var/mail"
+#define	_PATH_MAN	"/data/data/com.termux/files/usr/share/man"
 #define	_PATH_MEM	"/dev/mem"
-#define	_PATH_MNTTAB	"/etc/fstab"
-#define	_PATH_MOUNTED	"/etc/mtab"
-#define	_PATH_NOLOGIN	"/etc/nologin"
-#define	_PATH_PRESERVE	"/var/lib"
-#define	_PATH_RWHODIR	"/var/spool/rwho"
-#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
-#define	_PATH_SHADOW	"/etc/shadow"
-#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_MNTTAB	"/data/data/com.termux/files/usr/etc/fstab"
+#define	_PATH_MOUNTED	"/data/data/com.termux/files/usr/etc/mtab"
+#define	_PATH_NOLOGIN	"/data/data/com.termux/files/usr/etc/nologin"
+#define	_PATH_PRESERVE	"/data/data/com.termux/files/usr/var/lib"
+#define	_PATH_RWHODIR	"/data/data/com.termux/files/usr/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/data/data/com.termux/files/usr/bin/sendmail"
+#define	_PATH_SHADOW	"/data/data/com.termux/files/usr/etc/shadow"
+#define	_PATH_SHELLS	"/data/data/com.termux/files/usr/etc/shells"
 #define	_PATH_TTY	"/dev/tty"
 #define	_PATH_UNIX	"/boot/vmlinux"
-#define	_PATH_UTMP	"/var/run/utmp"
-#define	_PATH_VI	"/usr/bin/vi"
-#define	_PATH_WTMP	"/var/log/wtmp"
+#define	_PATH_UTMP	"/data/data/com.termux/files/usr/var/run/utmp"
+#define	_PATH_VI	"/data/data/com.termux/files/usr/bin/vi"
+#define	_PATH_WTMP	"/data/data/com.termux/files/usr/var/log/wtmp"
 
 /* Provide trailing slash, since mostly used for building pathnames. */
 #define	_PATH_DEV	"/dev/"
-#define	_PATH_TMP	"/tmp/"
-#define	_PATH_VARDB	"/var/db/"
-#define	_PATH_VARRUN	"/var/run/"
-#define	_PATH_VARTMP	"/var/tmp/"
+#define	_PATH_TMP	"/data/data/com.termux/files/usr/tmp/"
+#define	_PATH_VARDB	"/data/data/com.termux/files/usr/var/db/"
+#define	_PATH_VARRUN	"/data/data/com.termux/files/usr/var/run/"
+#define	_PATH_VARTMP	"/data/data/com.termux/files/usr/var/tmp/"
 
 #endif /* !_PATHS_H_ */
diff -Narupa a/sysdeps/unix/sysv/linux/recv.c b/sysdeps/unix/sysv/linux/recv.c
--- a/sysdeps/unix/sysv/linux/recv.c
+++ b/sysdeps/unix/sysv/linux/recv.c
@@ -22,13 +22,7 @@
 ssize_t
 __libc_recv (int fd, void *buf, size_t len, int flags)
 {
-#ifdef __ASSUME_RECV_SYSCALL
-  return SYSCALL_CANCEL (recv, fd, buf, len, flags);
-#elif defined __ASSUME_RECVFROM_SYSCALL
   return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, NULL, NULL);
-#else
-  return SOCKETCALL_CANCEL (recv, fd, buf, len, flags);
-#endif
 }
 weak_alias (__libc_recv, recv)
 weak_alias (__libc_recv, __recv)
diff -Narupa a/sysdeps/unix/sysv/linux/riscv/clone3.S b/sysdeps/unix/sysv/linux/riscv/clone3.S
--- a/sysdeps/unix/sysv/linux/riscv/clone3.S
+++ b/sysdeps/unix/sysv/linux/riscv/clone3.S
@@ -1,79 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/RISC-V version.
-   Copyright (C) 2023-2024 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <asm/errno.h>
-#include <sys/asm.h>
-#include <sysdep.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-               int (*func)(void *arg), void *arg);
-
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   a0: cl_args
-   a1: size
-   a2: func
-   a3: arg  */
-
-        .text
-ENTRY(__clone3)
-	/* Sanity check args.  */
-	beqz	a0, L(invalid)	/* No NULL cl_args pointer.  */
-	beqz	a2, L(invalid)  /* No NULL function pointer.  */
-
-	/* Do the system call, the kernel expects:
-	   a7: system call number
-	   a0: cl_args
-	   a1: size  */
-	li	a7, __NR_clone3
-	scall
-
-	bltz	a0, L(error)
-	beqz	a0, L(thread_start)
-
-	ret
-
-L(invalid):
-	li	a0, -EINVAL
-L(error):
-	tail	__syscall_error
-END (__clone3)
-
-ENTRY(__thread_start_clone3)
-L(thread_start):
-	/* Terminate call stack by noting ra is undefined.  Use a dummy
-	   .cfi_label to force starting the FDE.  */
-	.cfi_label .Ldummy
-	cfi_undefined (ra)
-
-	/* Restore the arg for user's function and call the user's
-	   function.  */
-	mv		a0, a3	/* Argument pointer.  */
-	jalr		a2
-
-	/* Call exit with the function's return value.  */
-	li		a7, __NR_exit
-	scall
-END(__thread_start_clone3)
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/riscv/dl-cache.h b/sysdeps/unix/sysv/linux/riscv/dl-cache.h
--- a/sysdeps/unix/sysv/linux/riscv/dl-cache.h
+++ b/sysdeps/unix/sysv/linux/riscv/dl-cache.h
@@ -58,7 +58,7 @@
 	"/lib32/ilp32",							\
 	NULL,								\
       };								\
-      const size_t lib_len = sizeof ("/lib") - 1;			\
+      const size_t lib_len = sizeof ("/data/data/com.termux/files/usr/lib") - 1;			\
       size_t len = strlen (dir);					\
       char path[len + 10];						\
       const char **ptr;							\
diff -Narupa a/sysdeps/unix/sysv/linux/rmdir.c b/sysdeps/unix/sysv/linux/rmdir.c
--- a/sysdeps/unix/sysv/linux/rmdir.c
+++ b/sysdeps/unix/sysv/linux/rmdir.c
@@ -24,10 +24,6 @@
 int
 __rmdir (const char *path)
 {
-#ifdef __NR_rmdir
-  return INLINE_SYSCALL_CALL (rmdir, path);
-#else
   return INLINE_SYSCALL_CALL (unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
-#endif
 }
 weak_alias (__rmdir, rmdir)
diff -Narupa a/sysdeps/unix/sysv/linux/rseq-internal.h b/sysdeps/unix/sysv/linux/rseq-internal.h
--- a/sysdeps/unix/sysv/linux/rseq-internal.h
+++ b/sysdeps/unix/sysv/linux/rseq-internal.h
@@ -25,28 +25,11 @@
 #include <stdio.h>
 #include <sys/rseq.h>
 
-#ifdef RSEQ_SIG
 static inline bool
 rseq_register_current_thread (struct pthread *self, bool do_rseq)
 {
-  if (do_rseq)
-    {
-      int ret = INTERNAL_SYSCALL_CALL (rseq, &self->rseq_area,
-                                       sizeof (self->rseq_area),
-                                       0, RSEQ_SIG);
-      if (!INTERNAL_SYSCALL_ERROR_P (ret))
-        return true;
-    }
   THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
   return false;
 }
-#else /* RSEQ_SIG */
-static inline bool
-rseq_register_current_thread (struct pthread *self, bool do_rseq)
-{
-  THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
-  return false;
-}
-#endif /* RSEQ_SIG */
 
 #endif /* rseq-internal.h */
diff -Narupa a/sysdeps/unix/sysv/linux/send.c b/sysdeps/unix/sysv/linux/send.c
--- a/sysdeps/unix/sysv/linux/send.c
+++ b/sysdeps/unix/sysv/linux/send.c
@@ -22,13 +22,7 @@
 ssize_t
 __libc_send (int fd, const void *buf, size_t len, int flags)
 {
-#ifdef __ASSUME_SEND_SYSCALL
-  return SYSCALL_CANCEL (send, fd, buf, len, flags);
-#elif defined __ASSUME_SENDTO_SYSCALL
   return SYSCALL_CANCEL (sendto, fd, buf, len, flags, NULL, 0);
-#else
-  return SOCKETCALL_CANCEL (send, fd, buf, len, flags);
-#endif
 }
 weak_alias (__libc_send, send)
 weak_alias (__libc_send, __send)
diff -Narupa a/sysdeps/unix/sysv/linux/setegid.c b/sysdeps/unix/sysv/linux/setegid.c
--- a/sysdeps/unix/sysv/linux/setegid.c
+++ b/sysdeps/unix/sysv/linux/setegid.c
@@ -28,13 +28,7 @@ setegid (gid_t gid)
   if (gid == (gid_t) ~0)
     return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
 
-#ifdef __NR_setresgid32
-  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);
-#else
-  result = INLINE_SETXID_SYSCALL (setresgid, 3, -1, gid, -1);
-#endif
-
-  return result;
+  return 0;
 }
 #ifndef setegid
 libc_hidden_def (setegid)
diff -Narupa a/sysdeps/unix/sysv/linux/setgid.c b/sysdeps/unix/sysv/linux/setgid.c
--- a/sysdeps/unix/sysv/linux/setgid.c
+++ b/sysdeps/unix/sysv/linux/setgid.c
@@ -23,11 +23,7 @@
 int
 __setgid (gid_t gid)
 {
-#ifdef __NR_setgid32
-  return INLINE_SETXID_SYSCALL (setgid32, 1, gid);
-#else
-  return INLINE_SETXID_SYSCALL (setgid, 1, gid);
-#endif
+  return 0;
 }
 #ifndef __setgid
 weak_alias (__setgid, setgid)
diff -Narupa a/sysdeps/unix/sysv/linux/setresgid.c b/sysdeps/unix/sysv/linux/setresgid.c
--- a/sysdeps/unix/sysv/linux/setresgid.c
+++ b/sysdeps/unix/sysv/linux/setresgid.c
@@ -23,11 +23,7 @@
 int
 __setresgid (gid_t rgid, gid_t egid, gid_t sgid)
 {
-#ifdef __NR_setresgid32
-  return INLINE_SETXID_SYSCALL (setresgid32, 3, rgid, egid, sgid);
-#else
-  return INLINE_SETXID_SYSCALL (setresgid, 3, rgid, egid, sgid);
-#endif
+  return 0;
 }
 libc_hidden_def (__setresgid)
 #ifndef __setresgid
diff -Narupa a/sysdeps/unix/sysv/linux/setuid.c b/sysdeps/unix/sysv/linux/setuid.c
--- a/sysdeps/unix/sysv/linux/setuid.c
+++ b/sysdeps/unix/sysv/linux/setuid.c
@@ -22,11 +22,7 @@
 int
 __setuid (uid_t uid)
 {
-#ifdef __NR_setuid32
-  return INLINE_SETXID_SYSCALL (setuid32, 1, uid);
-#else
-  return INLINE_SETXID_SYSCALL (setuid, 1, uid);
-#endif
+  return 0;
 }
 #ifndef __setuid
 weak_alias (__setuid, setuid)
diff -Narupa a/sysdeps/unix/sysv/linux/shmat.c b/sysdeps/unix/sysv/linux/shmat.c
--- a/sysdeps/unix/sysv/linux/shmat.c
+++ b/sysdeps/unix/sysv/linux/shmat.c
@@ -1,42 +1,44 @@
-/* Copyright (C) 1995-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <shmem-android.h>
+#include <sys/mman.h>
 
 /* Attach the shared memory segment associated with SHMID to the data
    segment of the calling process.  SHMADDR and SHMFLG determine how
    and where the segment is attached.  */
 
-void *
-shmat (int shmid, const void *shmaddr, int shmflg)
+void* shmat(int shmid, void const* shmaddr, int shmflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return (void*) INLINE_SYSCALL_CALL (shmat, shmid, shmaddr, shmflg);
-#else
-  unsigned long resultvar;
-  void *raddr;
-
-  resultvar = INTERNAL_SYSCALL_CALL (ipc, IPCOP_shmat, shmid, shmflg,
-				     &raddr, shmaddr);
-  if (INTERNAL_SYSCALL_ERROR_P (resultvar))
-    return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (resultvar));
+	ashv_check_pid();
+
+	int socket_id = ashv_socket_id_from_shmid(shmid);
+	void *addr;
+
+	pthread_mutex_lock(&mutex);
+
+	int idx = ashv_find_local_index(shmid);
+	if (idx == -1 && socket_id != ashv_local_socket_id) {
+		idx = ashv_read_remote_segment(shmid);
+	}
+
+	if (idx == -1) {
+		DBG ("%s: shmid %x does not exist\n", __PRETTY_FUNCTION__, shmid);
+		pthread_mutex_unlock(&mutex);
+		errno = EINVAL;
+		return (void*) -1;
+	}
+
+	if (shmem[idx].addr == NULL) {
+		shmem[idx].addr = mmap((void*) shmaddr, shmem[idx].size, PROT_READ | (shmflg == 0 ? PROT_WRITE : 0), MAP_SHARED, shmem[idx].descriptor, 0);
+		if (shmem[idx].addr == MAP_FAILED) {
+			DBG ("%s: mmap() failed for ID %x FD %d: %s\n", __PRETTY_FUNCTION__, idx, shmem[idx].descriptor, strerror(errno));
+			shmem[idx].addr = NULL;
+		}
+	}
+	addr = shmem[idx].addr;
+	DBG ("%s: mapped addr %p for FD %d ID %d\n", __PRETTY_FUNCTION__, addr, shmem[idx].descriptor, idx);
+	pthread_mutex_unlock (&mutex);
 
-  return raddr;
-#endif
+	return addr ? addr : (void *)-1;
 }
diff -Narupa a/sysdeps/unix/sysv/linux/shmctl.c b/sysdeps/unix/sysv/linux/shmctl.c
--- a/sysdeps/unix/sysv/linux/shmctl.c
+++ b/sysdeps/unix/sysv/linux/shmctl.c
@@ -1,291 +1,75 @@
-/* Copyright (C) 1995-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sys/shm.h>
 #include <stdarg.h>
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <shlib-compat.h>
 #include <errno.h>
-#include <linux/posix_types.h>  /* For __kernel_mode_t.  */
+#include <shmem-android.h>
+#include <asm-generic/ipcbuf.h>
+#include <asm-generic/shmbuf.h>
+
+#ifndef shmid_ds
+# define shmid_ds shmid64_ds
+#endif
+
+int shmctl(int shmid, int cmd, struct shmid_ds *buf)
+{
+	ashv_check_pid();
+
+	if (cmd == IPC_RMID) {
+		DBG("%s: IPC_RMID for shmid=%x\n", __PRETTY_FUNCTION__, shmid);
+		pthread_mutex_lock(&mutex);
+		int idx = ashv_find_local_index(shmid);
+		if (idx == -1) {
+			DBG("%s: shmid=%x does not exist locally\n", __PRETTY_FUNCTION__, shmid);
+			/* We do not rm non-local regions, but do not report an error for that. */
+			pthread_mutex_unlock(&mutex);
+			return 0;
+		}
+
+		if (shmem[idx].addr) {
+			// shmctl(2): The segment will actually be destroyed only
+			// after the last process detaches it (i.e., when the shm_nattch
+			// member of the associated structure shmid_ds is zero.
+			shmem[idx].markedForDeletion = true;
+		} else {
+			android_shmem_delete(idx);
+		}
+		pthread_mutex_unlock(&mutex);
+		return 0;
+	} else if (cmd == IPC_STAT) {
+		if (!buf) {
+			DBG ("%s: ERROR: buf == NULL for shmid %x\n", __PRETTY_FUNCTION__, shmid);
+			errno = EINVAL;
+			return -1;
+		}
+
+		pthread_mutex_lock(&mutex);
+		int idx = ashv_find_local_index(shmid);
+		if (idx == -1) {
+			DBG ("%s: ERROR: shmid %x does not exist\n", __PRETTY_FUNCTION__, shmid);
+			pthread_mutex_unlock (&mutex);
+			errno = EINVAL;
+			return -1;
+		}
+		/* Report max permissive mode */
+		memset(buf, 0, sizeof(struct shmid_ds));
+		buf->shm_segsz = shmem[idx].size;
+		buf->shm_nattch = 1;
+		buf->shm_perm.key = shmem[idx].key;
+		buf->shm_perm.uid = geteuid();
+		buf->shm_perm.gid = getegid();
+		buf->shm_perm.cuid = geteuid();
+		buf->shm_perm.cgid = getegid();
+		buf->shm_perm.mode = 0666;
+		buf->shm_perm.seq = 1;
 
-/* POSIX states ipc_perm mode should have type of mode_t.  */
-_Static_assert (sizeof ((struct shmid_ds){0}.shm_perm.mode)
-		== sizeof (mode_t),
-		"sizeof (shmid_ds.shm_perm.mode) != sizeof (mode_t)");
-
-#if __IPC_TIME64 == 0
-typedef struct shmid_ds shmctl_arg_t;
-#else
-# include <struct_kernel_shmid64_ds.h>
-
-static void
-shmid64_to_kshmid64 (const struct __shmid64_ds *shmid64,
-		     struct kernel_shmid64_ds *kshmid)
-{
-  kshmid->shm_perm       = shmid64->shm_perm;
-  kshmid->shm_segsz      = shmid64->shm_segsz;
-  kshmid->shm_atime      = shmid64->shm_atime;
-  kshmid->shm_atime_high = shmid64->shm_atime >> 32;
-  kshmid->shm_dtime      = shmid64->shm_dtime;
-  kshmid->shm_dtime_high = shmid64->shm_dtime >> 32;
-  kshmid->shm_ctime      = shmid64->shm_ctime;
-  kshmid->shm_ctime_high = shmid64->shm_ctime >> 32;
-  kshmid->shm_cpid       = shmid64->shm_cpid;
-  kshmid->shm_lpid       = shmid64->shm_lpid;
-  kshmid->shm_nattch     = shmid64->shm_nattch;
-}
-
-static void
-kshmid64_to_shmid64 (const struct kernel_shmid64_ds *kshmid,
-		     struct __shmid64_ds *shmid64)
-{
-  shmid64->shm_perm   = kshmid->shm_perm;
-  shmid64->shm_segsz  = kshmid->shm_segsz;
-  shmid64->shm_atime  = kshmid->shm_atime
-		        | ((__time64_t) kshmid->shm_atime_high << 32);
-  shmid64->shm_dtime  = kshmid->shm_dtime
-		        | ((__time64_t) kshmid->shm_dtime_high << 32);
-  shmid64->shm_ctime  = kshmid->shm_ctime
-		        | ((__time64_t) kshmid->shm_ctime_high << 32);
-  shmid64->shm_cpid   = kshmid->shm_cpid;
-  shmid64->shm_lpid   = kshmid->shm_lpid;
-  shmid64->shm_nattch = kshmid->shm_nattch;
-}
-
-typedef struct kernel_shmid64_ds shmctl_arg_t;
-#endif
-
-static int
-shmctl_syscall (int shmid, int cmd, shmctl_arg_t *buf)
-{
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmctl, shmid, cmd | __IPC_64, buf);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmctl, shmid, cmd | __IPC_64, 0,
-			      buf);
-#endif
-}
-
-/* Provide operations to control over shared memory segments.  */
-int
-__shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf)
-{
-#if IPC_CTL_NEED_TRANSLATION
-# if __IPC_TIME64
-  struct kernel_shmid64_ds kshmid, *arg = NULL;
-# else
-  shmctl_arg_t *arg;
-# endif
-
-  /* Some applications pass the __IPC_64 flag in cmd, to invoke
-     previously unsupported commands back when there was no EINVAL
-     error checking in glibc.  Mask the flag for the switch statements
-     below.  shmctl_syscall adds back the __IPC_64 flag for the actual
-     system call.  */
-  cmd &= ~__IPC_64;
-
-  switch (cmd)
-    {
-    case IPC_RMID:
-    case SHM_LOCK:
-    case SHM_UNLOCK:
-      arg = NULL;
-      break;
-
-    case IPC_SET:
-    case IPC_STAT:
-    case SHM_STAT:
-    case SHM_STAT_ANY:
-# if __IPC_TIME64
-      if (buf != NULL)
-	{
-	  shmid64_to_kshmid64 (buf, &kshmid);
-	  arg = &kshmid;
+		pthread_mutex_unlock (&mutex);
+		return 0;
 	}
-#  ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-      if (cmd == IPC_SET)
-        arg->shm_perm.mode *= 0x10000U;
-#  endif
-# else
-      arg = buf;
-# endif
-      break;
-
-    case IPC_INFO:
-    case SHM_INFO:
-      /* This is a Linux extension where kernel expects either a
-	 'struct shminfo' (IPC_INFO) or 'struct shm_info' (SHM_INFO).  */
-      arg = (__typeof__ (arg)) buf;
-      break;
-
-    default:
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-
-  int ret = shmctl_syscall (shmid, cmd, arg);
-  if (ret < 0)
-    return ret;
-
-  switch (cmd)
-    {
-      case IPC_STAT:
-      case SHM_STAT:
-      case SHM_STAT_ANY:
-# ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-        arg->shm_perm.mode >>= 16;
-# else
-      /* Old Linux kernel versions might not clear the mode padding.  */
-      if (sizeof ((struct shmid_ds){0}.shm_perm.mode)
-	  != sizeof (__kernel_mode_t))
-	arg->shm_perm.mode &= 0xFFFF;
-# endif
-
-# if __IPC_TIME64
-      kshmid64_to_shmid64 (arg, buf);
-# endif
-    }
-
-  return ret;
 
-#else /* !IPC_CTL_NEED_TRANSLATION */
-  return shmctl_syscall (shmid, cmd, buf);
-#endif
-}
-#if __TIMESIZE != 64
-libc_hidden_def (__shmctl64)
-
-static void
-shmid_to_shmid64 (struct __shmid64_ds *shm64, const struct shmid_ds *shm)
-{
-  shm64->shm_perm   = shm->shm_perm;
-  shm64->shm_segsz  = shm->shm_segsz;
-  shm64->shm_atime  = shm->shm_atime
-		      | ((__time64_t) shm->__shm_atime_high << 32);
-  shm64->shm_dtime  = shm->shm_dtime
-		      | ((__time64_t) shm->__shm_dtime_high << 32);
-  shm64->shm_ctime  = shm->shm_ctime
-		      | ((__time64_t) shm->__shm_ctime_high << 32);
-  shm64->shm_cpid   = shm->shm_cpid;
-  shm64->shm_lpid   = shm->shm_lpid;
-  shm64->shm_nattch = shm->shm_nattch;
-}
-
-static void
-shmid64_to_shmid (struct shmid_ds *shm, const struct __shmid64_ds *shm64)
-{
-  shm->shm_perm         = shm64->shm_perm;
-  shm->shm_segsz        = shm64->shm_segsz;
-  shm->shm_atime        = shm64->shm_atime;
-  shm->__shm_atime_high = 0;
-  shm->shm_dtime        = shm64->shm_dtime;
-  shm->__shm_dtime_high = 0;
-  shm->shm_ctime        = shm64->shm_ctime;
-  shm->__shm_ctime_high = 0;
-  shm->shm_cpid         = shm64->shm_cpid;
-  shm->shm_lpid         = shm64->shm_lpid;
-  shm->shm_nattch       = shm64->shm_nattch;
-}
-
-int
-__shmctl (int shmid, int cmd, struct shmid_ds *buf)
-{
-  struct __shmid64_ds shmid64, *buf64 = NULL;
-  if (buf != NULL)
-    {
-      /* This is a Linux extension where kernel expects either a
-	 'struct shminfo' (IPC_INFO) or 'struct shm_info' (SHM_INFO).  */
-      if (cmd == IPC_INFO || cmd == SHM_INFO)
-	buf64 = (struct __shmid64_ds *) buf;
-      else
-	{
-	  shmid_to_shmid64 (&shmid64, buf);
-	  buf64 = &shmid64;
-	}
-    }
-
-  int ret = __shmctl64 (shmid, cmd, buf64);
-  if (ret < 0)
-    return ret;
-
-  switch (cmd)
-    {
-      case IPC_STAT:
-      case SHM_STAT:
-      case SHM_STAT_ANY:
-	shmid64_to_shmid (buf, buf64);
-    }
-
-  return ret;
+	DBG("%s: cmd %d not implemented yet!\n", __PRETTY_FUNCTION__, cmd);
+	errno = EINVAL;
+	return -1;
 }
-#endif
-
-#ifndef DEFAULT_VERSION
-# ifndef __ASSUME_SYSVIPC_BROKEN_MODE_T
-#  define DEFAULT_VERSION GLIBC_2_2
-# else
-#  define DEFAULT_VERSION GLIBC_2_31
-# endif
-#endif
-
-versioned_symbol (libc, __shmctl, shmctl, DEFAULT_VERSION);
-
-#if defined __ASSUME_SYSVIPC_BROKEN_MODE_T \
-    && SHLIB_COMPAT (libc, GLIBC_2_2, GLIBC_2_31)
-int
-attribute_compat_text_section
-__shmctl_mode16 (int shmid, int cmd, struct shmid_ds *buf)
-{
-  return shmctl_syscall (shmid, cmd, (shmctl_arg_t *) buf);
-}
-compat_symbol (libc, __shmctl_mode16, shmctl, GLIBC_2_2);
-#endif
-
-#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
-struct __old_shmid_ds
-{
-  struct __old_ipc_perm shm_perm;	/* operation permission struct */
-  int shm_segsz;			/* size of segment in bytes */
-  __time_t shm_atime;			/* time of last shmat() */
-  __time_t shm_dtime;			/* time of last shmdt() */
-  __time_t shm_ctime;			/* time of last change by shmctl() */
-  __ipc_pid_t shm_cpid;			/* pid of creator */
-  __ipc_pid_t shm_lpid;			/* pid of last shmop */
-  unsigned short int shm_nattch;	/* number of current attaches */
-  unsigned short int __shm_npages;	/* size of segment (pages) */
-  unsigned long int *__shm_pages;	/* array of ptrs to frames -> SHMMAX */
-  struct vm_area_struct *__attaches;	/* descriptors for attaches */
-};
 
-int
-attribute_compat_text_section
-__old_shmctl (int shmid, int cmd, struct __old_shmid_ds *buf)
-{
-#if defined __ASSUME_DIRECT_SYSVIPC_SYSCALLS \
-    && !defined __ASSUME_SYSVIPC_DEFAULT_IPC_64
-  /* For architecture that have wire-up shmctl but also have __IPC_64 to a
-     value different than default (0x0), it means the compat symbol used the
-     __NR_ipc syscall.  */
-  return INLINE_SYSCALL_CALL (shmctl, shmid, cmd, buf);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmctl, shmid, cmd, 0, buf);
-#endif
-}
-compat_symbol (libc, __old_shmctl, shmctl, GLIBC_2_0);
-#endif
+weak_alias (shmctl, __shmctl64)
diff -Narupa a/sysdeps/unix/sysv/linux/shmdt.c b/sysdeps/unix/sysv/linux/shmdt.c
--- a/sysdeps/unix/sysv/linux/shmdt.c
+++ b/sysdeps/unix/sysv/linux/shmdt.c
@@ -1,33 +1,35 @@
-/* Copyright (C) 1995-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <shmem-android.h>
+#include <sys/mman.h>
 
 /* Detach shared memory segment starting at address specified by SHMADDR
    from the caller's data segment.  */
 
-int
-shmdt (const void *shmaddr)
+int shmdt(void const* shmaddr)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmdt, shmaddr);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmdt, 0, 0, 0, shmaddr);
-#endif
+	ashv_check_pid();
+
+	pthread_mutex_lock(&mutex);
+	for (size_t i = 0; i < shmem_amount; i++) {
+		if (shmem[i].addr == shmaddr) {
+			if (munmap(shmem[i].addr, shmem[i].size) != 0) {
+				DBG("%s: munmap %p failed\n", __PRETTY_FUNCTION__, shmaddr);
+			}
+			shmem[i].addr = NULL;
+			DBG("%s: unmapped addr %p for FD %d ID %zu shmid %x\n", __PRETTY_FUNCTION__, shmaddr, shmem[i].descriptor, i, shmem[i].id);
+			if (shmem[i].markedForDeletion || ashv_socket_id_from_shmid(shmem[i].id) != ashv_local_socket_id) {
+				DBG ("%s: deleting shmid %x\n", __PRETTY_FUNCTION__, shmem[i].id);
+				android_shmem_delete(i);
+			}
+			pthread_mutex_unlock(&mutex);
+			return 0;
+		}
+	}
+	pthread_mutex_unlock(&mutex);
+
+	DBG("%s: invalid address %p\n", __PRETTY_FUNCTION__, shmaddr);
+	/* Could be a remove segment, do not report an error for that. */
+	return 0;
 }
diff -Narupa a/sysdeps/unix/sysv/linux/shmem-android.h b/sysdeps/unix/sysv/linux/shmem-android.h
--- a/sysdeps/unix/sysv/linux/shmem-android.h
+++ b/sysdeps/unix/sysv/linux/shmem-android.h
@@ -0,0 +1,298 @@
+/* <shmem-android.h> - dependencies (values and commands) for system V shared
+ * memory emulation on Android using ashmem. Needed in the following files:
+ * - shmat.c
+ * - shmctl.c
+ * - shmdt.c
+ * - shmget.c
+ *
+ * The code was taken from the libandroid-shmem repo:
+ * <https://github.com/termux/libandroid-shmem>
+ *
+ * PS: it's adding libandroid-shmem to the glibc system with some modifications
+ * to make it work on a glibc basis.
+ */
+
+#ifndef __SHMEM_ANDROID
+#define __SHMEM_ANDROID
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <paths.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdio.h>
+
+#define __u32 uint32_t
+
+#ifdef ENABLE_DEBUG_SHMEM_ANDROID
+# define DBG(...) printf(__VA_ARGS__)
+#else
+# define DBG(...)
+#endif //ENABLE_DEBUG_SHMEM_ANDROID
+
+#define __ASHMEMIOC 0x77
+#define ASHMEM_NAME_LEN 256
+#define ASHMEM_GET_SIZE _IO(__ASHMEMIOC, 4)
+#define ASHMEM_SET_SIZE _IOW(__ASHMEMIOC, 3, size_t)
+#define ASHMEM_SET_NAME _IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
+
+#define ASHV_KEY_SYMLINK_PATH _PATH_TMP "ashv_key_%d"
+#define ANDROID_SHMEM_SOCKNAME "/dev/shm/%08x"
+#define ROUND_UP(N, S) ((((N) + (S) - 1) / (S)) * (S))
+
+typedef struct {
+	int id;
+	void *addr;
+	int descriptor;
+	size_t size;
+	bool markedForDeletion;
+	key_t key;
+} shmem_t;
+
+static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static shmem_t* shmem = NULL;
+static size_t shmem_amount = 0;
+static int ashv_local_socket_id = 0;
+static int ashv_pid_setup = 0;
+static pthread_t ashv_listening_thread_id = 0;
+
+static int ancil_send_fd(int sock, int fd)
+{
+	char nothing = '!';
+	struct iovec nothing_ptr = { .iov_base = &nothing, .iov_len = 1 };
+
+	struct {
+		struct cmsghdr align;
+		int fd[1];
+	} ancillary_data_buffer;
+
+	struct msghdr message_header = {
+		.msg_name = NULL,
+		.msg_namelen = 0,
+		.msg_iov = &nothing_ptr,
+		.msg_iovlen = 1,
+		.msg_flags = 0,
+		.msg_control = &ancillary_data_buffer,
+		.msg_controllen = sizeof(struct cmsghdr) + sizeof(int)
+	};
+
+	struct cmsghdr* cmsg = CMSG_FIRSTHDR(&message_header);
+	cmsg->cmsg_len = message_header.msg_controllen; // sizeof(int);
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = SCM_RIGHTS;
+	((int*) CMSG_DATA(cmsg))[0] = fd;
+
+	return sendmsg(sock, &message_header, 0) >= 0 ? 0 : -1;
+}
+
+static int ancil_recv_fd(int sock)
+{
+	char nothing = '!';
+	struct iovec nothing_ptr = { .iov_base = &nothing, .iov_len = 1 };
+
+	struct {
+		struct cmsghdr align;
+		int fd[1];
+	} ancillary_data_buffer;
+
+	struct msghdr message_header = {
+		.msg_name = NULL,
+		.msg_namelen = 0,
+		.msg_iov = &nothing_ptr,
+		.msg_iovlen = 1,
+		.msg_flags = 0,
+		.msg_control = &ancillary_data_buffer,
+		.msg_controllen = sizeof(struct cmsghdr) + sizeof(int)
+	};
+
+	struct cmsghdr* cmsg = CMSG_FIRSTHDR(&message_header);
+	cmsg->cmsg_len = message_header.msg_controllen;
+	cmsg->cmsg_level = SOL_SOCKET;
+	cmsg->cmsg_type = SCM_RIGHTS;
+	((int*) CMSG_DATA(cmsg))[0] = -1;
+
+	if (recvmsg(sock, &message_header, 0) < 0) return -1;
+
+	return ((int*) CMSG_DATA(cmsg))[0];
+}
+
+static int ashmem_get_size_region(int fd)
+{
+	//int ret = __ashmem_is_ashmem(fd, 1);
+	//if (ret < 0) return ret;
+	return TEMP_FAILURE_RETRY(ioctl(fd, ASHMEM_GET_SIZE, NULL));
+}
+
+/*
+ * From https://android.googlesource.com/platform/system/core/+/master/libcutils/ashmem-dev.c
+ *
+ * ashmem_create_region - creates a new named ashmem region and returns the file
+ * descriptor, or <0 on error.
+ *
+ * `name' is the label to give the region (visible in /proc/pid/maps)
+ * `size' is the size of the region, in page-aligned bytes
+ */
+static int ashmem_create_region(char const* name, size_t size)
+{
+	int fd = open("/dev/ashmem", O_RDWR);
+	if (fd < 0) return fd;
+
+	char name_buffer[ASHMEM_NAME_LEN] = {0};
+	strncpy(name_buffer, name, sizeof(name_buffer));
+	name_buffer[sizeof(name_buffer)-1] = 0;
+
+	int ret = ioctl(fd, ASHMEM_SET_NAME, name_buffer);
+	if (ret < 0) goto error;
+
+	ret = ioctl(fd, ASHMEM_SET_SIZE, size);
+	if (ret < 0) goto error;
+
+	return fd;
+error:
+	close(fd);
+	return ret;
+}
+
+static void ashv_check_pid()
+{
+	pid_t mypid = getpid();
+	if (ashv_pid_setup == 0) {
+		ashv_pid_setup = mypid;
+	} else if (ashv_pid_setup != mypid) {
+		DBG("%s: Cleaning to new pid=%d from oldpid=%d", __PRETTY_FUNCTION__, mypid, ashv_pid_setup);
+		// We inherited old state across a fork.
+		ashv_pid_setup = mypid;
+		ashv_local_socket_id = 0;
+		ashv_listening_thread_id = 0;
+		shmem_amount = 0;
+		// Unlock if fork left us with held lock from parent thread.
+		pthread_mutex_unlock(&mutex);
+		if (shmem != NULL) free(shmem);
+		shmem = NULL;
+	}
+}
+
+
+// Store index in the lower 15 bits and the socket id in the
+// higher 16 bits.
+static int ashv_shmid_from_counter(unsigned int counter)
+{
+	return ashv_local_socket_id * 0x10000 + counter;
+}
+
+static int ashv_socket_id_from_shmid(int shmid)
+{
+	return shmid / 0x10000;
+}
+
+static int ashv_find_local_index(int shmid)
+{
+	for (size_t i = 0; i < shmem_amount; i++)
+		if (shmem[i].id == shmid)
+			return i;
+	return -1;
+}
+
+static void* ashv_thread_function(void* arg)
+{
+	int sock = *(int*)arg;
+	free(arg);
+	struct sockaddr_un addr;
+	socklen_t len = sizeof(addr);
+	int sendsock;
+	DBG("%s: thread started", __PRETTY_FUNCTION__);
+	while ((sendsock = accept(sock, (struct sockaddr *)&addr, &len)) != -1) {
+		int shmid;
+		if (recv(sendsock, &shmid, sizeof(shmid), 0) != sizeof(shmid)) {
+			DBG("%s: ERROR: recv() returned not %zu bytes", __PRETTY_FUNCTION__, sizeof(shmid));
+			close(sendsock);
+			continue;
+		}
+		pthread_mutex_lock(&mutex);
+		int idx = ashv_find_local_index(shmid);
+		if (idx != -1) {
+			if (write(sendsock, &shmem[idx].key, sizeof(key_t)) != sizeof(key_t)) {
+				DBG("%s: ERROR: write failed: %s", __PRETTY_FUNCTION__, strerror(errno));
+			}
+			if (ancil_send_fd(sendsock, shmem[idx].descriptor) != 0) {
+				DBG("%s: ERROR: ancil_send_fd() failed: %s", __PRETTY_FUNCTION__, strerror(errno));
+			}
+		} else {
+			DBG("%s: ERROR: cannot find shmid 0x%x", __PRETTY_FUNCTION__, shmid);
+		}
+		pthread_mutex_unlock(&mutex);
+		close(sendsock);
+		len = sizeof(addr);
+	}
+	DBG ("%s: ERROR: listen() failed, thread stopped", __PRETTY_FUNCTION__);
+	return NULL;
+}
+
+static void android_shmem_delete(int idx)
+{
+	if (shmem[idx].descriptor) close(shmem[idx].descriptor);
+	shmem_amount--;
+	memmove(&shmem[idx], &shmem[idx+1], (shmem_amount - idx) * sizeof(shmem_t));
+}
+
+static int ashv_read_remote_segment(int shmid)
+{
+	struct sockaddr_un addr;
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_UNIX;
+	sprintf(&addr.sun_path[1], ANDROID_SHMEM_SOCKNAME, ashv_socket_id_from_shmid(shmid));
+	int addrlen = sizeof(addr.sun_family) + strlen(&addr.sun_path[1]) + 1;
+
+	int recvsock = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (recvsock == -1) {
+		DBG ("%s: cannot create UNIX socket: %s", __PRETTY_FUNCTION__, strerror(errno));
+		return -1;
+	}
+	if (connect(recvsock, (struct sockaddr*) &addr, addrlen) != 0) {
+		DBG("%s: Cannot connect to UNIX socket %s: %s, len %d", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno), addrlen);
+		close(recvsock);
+		return -1;
+	}
+
+	if (send(recvsock, &shmid, sizeof(shmid), 0) != sizeof(shmid)) {
+		DBG ("%s: send() failed on socket %s: %s", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno));
+		close(recvsock);
+		return -1;
+	}
+
+	key_t key;
+	if (read(recvsock, &key, sizeof(key_t)) != sizeof(key_t)) {
+		DBG("%s: ERROR: failed read", __PRETTY_FUNCTION__);
+		close(recvsock);
+		return -1;
+	}
+
+	int descriptor = ancil_recv_fd(recvsock);
+	if (descriptor < 0) {
+		DBG("%s: ERROR: ancil_recv_fd() failed on socket %s: %s", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno));
+		close(recvsock);
+		return -1;
+	}
+	close(recvsock);
+
+	int size = ashmem_get_size_region(descriptor);
+	if (size == 0 || size == -1) {
+		DBG ("%s: ERROR: ashmem_get_size_region() returned %d on socket %s: %s", __PRETTY_FUNCTION__, size, addr.sun_path + 1, strerror(errno));
+		return -1;
+	}
+
+	int idx = shmem_amount;
+	shmem_amount ++;
+	shmem = realloc(shmem, shmem_amount * sizeof(shmem_t));
+	shmem[idx].id = shmid;
+	shmem[idx].descriptor = descriptor;
+	shmem[idx].size = size;
+	shmem[idx].addr = NULL;
+	shmem[idx].markedForDeletion = false;
+	shmem[idx].key = key;
+	return idx;
+}
+
+#endif /* __SHMEM_ANDROID */
diff -Narupa a/sysdeps/unix/sysv/linux/shmget.c b/sysdeps/unix/sysv/linux/shmget.c
--- a/sysdeps/unix/sysv/linux/shmget.c
+++ b/sysdeps/unix/sysv/linux/shmget.c
@@ -1,34 +1,152 @@
-/* Copyright (C) 1995-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
 #include <sys/msg.h>
 #include <stddef.h>
 #include <ipc_priv.h>
 #include <sysdep.h>
+#include <shmem-android.h>
 
 /* Return an identifier for an shared memory segment of at least size SIZE
    which is associated with KEY.  */
 
-int
-shmget (key_t key, size_t size, int shmflg)
+int shmget(key_t key, size_t size, int flags)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmget, key, size, shmflg, NULL);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmget, key, size, shmflg, NULL);
-#endif
+	(void) flags;
+
+	ashv_check_pid();
+
+	// Counter wrapping around at 15 bits.
+	static size_t shmem_counter = 0;
+
+	if (!ashv_listening_thread_id) {
+		int sock = socket(AF_UNIX, SOCK_STREAM, 0);
+		if (!sock) {
+			DBG ("%s: cannot create UNIX socket: %s\n", __PRETTY_FUNCTION__, strerror(errno));
+			errno = EINVAL;
+			return -1;
+		}
+		int i;
+		for (i = 0; i < 4096; i++) {
+			struct sockaddr_un addr;
+			int len;
+			memset (&addr, 0, sizeof(addr));
+			addr.sun_family = AF_UNIX;
+			ashv_local_socket_id = (getpid() + i) & 0xffff;
+			sprintf(&addr.sun_path[1], ANDROID_SHMEM_SOCKNAME, ashv_local_socket_id);
+			len = sizeof(addr.sun_family) + strlen(&addr.sun_path[1]) + 1;
+			if (bind(sock, (struct sockaddr *)&addr, len) != 0) continue;
+			DBG("%s: bound UNIX socket %s in pid=%d\n", __PRETTY_FUNCTION__, addr.sun_path + 1, getpid());
+			break;
+		}
+		if (i == 4096) {
+			DBG("%s: cannot bind UNIX socket, bailing out\n", __PRETTY_FUNCTION__);
+			ashv_local_socket_id = 0;
+			errno = ENOMEM;
+			return -1;
+		}
+		if (listen(sock, 4) != 0) {
+			DBG("%s: listen failed\n", __PRETTY_FUNCTION__);
+			errno = ENOMEM;
+			return -1;
+		}
+		int* socket_arg = malloc(sizeof(int));
+		*socket_arg = sock;
+		pthread_create(&ashv_listening_thread_id, NULL, &ashv_thread_function, socket_arg);
+	}
+
+	int shmid = -1;
+
+	pthread_mutex_lock(&mutex);
+	char symlink_path[256];
+	if (key != IPC_PRIVATE) {
+		// (1) Check if symlink exists telling us where to connect.
+		// (2) If so, try to connect and open.
+		// (3) If connected and opened, done. If connection refused
+		//     take ownership of the key and create the symlink.
+		// (4) If no symlink, create it.
+		sprintf(symlink_path, ASHV_KEY_SYMLINK_PATH, key);
+		char path_buffer[256];
+		char num_buffer[64];
+		while (true) {
+			int path_length = readlink(symlink_path, path_buffer, sizeof(path_buffer) - 1);
+			if (path_length != -1) {
+				path_buffer[path_length] = '\0';
+				int shmid = atoi(path_buffer);
+				if (shmid != 0) {
+					int idx = ashv_find_local_index(shmid);
+
+					if (idx == -1) {
+						idx = ashv_read_remote_segment(shmid);
+					}
+
+					if (idx != -1) {
+						pthread_mutex_unlock(&mutex);
+						return shmem[idx].id;
+					}
+				}
+				// TODO: Not sure we should try to remove previous owner if e.g.
+				// there was a tempporary failture to get a soket. Need to
+				// distinguish between why ashv_read_remote_segment failed.
+				unlink(symlink_path);
+			}
+			// Take ownership.
+			// TODO: HAndle error (out of resouces, no infinite loop)
+			if (shmid == -1) {
+				shmem_counter = (shmem_counter + 1) & 0x7fff;
+				shmid = ashv_shmid_from_counter(shmem_counter);
+				sprintf(num_buffer, "%d", shmid);
+			}
+			if (symlink(num_buffer, symlink_path) == 0) break;
+		}
+	}
+
+
+	int idx = shmem_amount;
+	char buf[256];
+	sprintf(buf, ANDROID_SHMEM_SOCKNAME "-%d", ashv_local_socket_id, idx);
+
+	shmem_amount++;
+	if (shmid == -1) {
+		shmem_counter = (shmem_counter + 1) & 0x7fff;
+		shmid = ashv_shmid_from_counter(shmem_counter);
+	}
+
+	shmem = realloc(shmem, shmem_amount * sizeof(shmem_t));
+	size = ROUND_UP(size, getpagesize());
+	shmem[idx].size = size;
+	shmem[idx].descriptor = ashmem_create_region(buf, size);
+	shmem[idx].addr = NULL;
+	shmem[idx].id = shmid;
+	shmem[idx].markedForDeletion = false;
+	shmem[idx].key = key;
+
+	if (shmem[idx].descriptor < 0) {
+		DBG("%s: ashmem_create_region() failed for size %zu: %s\n", __PRETTY_FUNCTION__, size, strerror(errno));
+		shmem_amount --;
+		shmem = realloc(shmem, shmem_amount * sizeof(shmem_t));
+		pthread_mutex_unlock (&mutex);
+		return -1;
+	}
+	//DBG("%s: ID %d shmid %x FD %d size %zu\n", __PRETTY_FUNCTION__, idx, shmid, shmem[idx].descriptor, shmem[idx].size);
+	/*
+	status = ashmem_set_prot_region (shmem[idx].descriptor, 0666);
+	if (status < 0) {
+		//DBG ("%s: ashmem_set_prot_region() failed for size %zu: %s %d\n", __PRETTY_FUNCTION__, size, strerror(status), status);
+		shmem_amount --;
+		shmem = realloc (shmem, shmem_amount * sizeof(shmem_t));
+		pthread_mutex_unlock (&mutex);
+		return -1;
+	}
+	*/
+	/*
+	status = ashmem_pin_region (shmem[idx].descriptor, 0, shmem[idx].size);
+	if (status < 0) {
+		//DBG ("%s: ashmem_pin_region() failed for size %zu: %s %d\n", __PRETTY_FUNCTION__, size, strerror(status), status);
+		shmem_amount --;
+		shmem = realloc (shmem, shmem_amount * sizeof(shmem_t));
+		pthread_mutex_unlock (&mutex);
+		return -1;
+	}
+	*/
+	pthread_mutex_unlock(&mutex);
+
+	return shmid;
 }
diff -Narupa a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
--- a/sysdeps/unix/sysv/linux/spawni.c
+++ b/sysdeps/unix/sysv/linux/spawni.c
@@ -265,7 +265,7 @@ __spawni_child (void *arguments)
 	    case spawn_do_closefrom:
 	      {
 		int lowfd = action->action.closefrom_action.from;
-	        int r = INLINE_SYSCALL_CALL (close_range, lowfd, ~0U, 0);
+	        int r = close_range (lowfd, ~0U, 0);
 		if (r != 0 && !__closefrom_fallback (lowfd, false))
 		  goto fail;
 	      } break;
@@ -412,13 +412,6 @@ __spawnix (int *pid, const char *file,
 	 on parent_tid.  */
       .parent_tid = use_pidfd ? (uintptr_t) &args.pidfd : 0,
     };
-#ifdef HAVE_CLONE3_WRAPPER
-  args.use_clone3 = true;
-  new_pid = __clone3 (&clone_args, sizeof (clone_args), __spawni_child,
-		      &args);
-  /* clone3 was added in 5.3 and CLONE_CLEAR_SIGHAND in 5.5.  */
-  if (new_pid == -1 && (errno == ENOSYS || errno == EINVAL))
-#endif
     {
       args.use_clone3 = false;
       if (!set_cgroup)
diff -Narupa a/sysdeps/unix/sysv/linux/statx.c b/sysdeps/unix/sysv/linux/statx.c
--- a/sysdeps/unix/sysv/linux/statx.c
+++ b/sysdeps/unix/sysv/linux/statx.c
@@ -25,14 +25,5 @@ int
 statx (int fd, const char *path, int flags,
        unsigned int mask, struct statx *buf)
 {
-  int ret = INLINE_SYSCALL_CALL (statx, fd, path, flags, mask, buf);
-#ifdef __ASSUME_STATX
-  return ret;
-#else
-  if (ret == 0 || errno != ENOSYS)
-    /* Preserve non-error/non-ENOSYS return values.  */
-    return ret;
-  else
-    return statx_generic (fd, path, flags, mask, buf);
-#endif
+  return statx_generic (fd, path, flags, mask, buf);
 }
diff -Narupa a/sysdeps/unix/sysv/linux/sys/pidfd.h b/sysdeps/unix/sysv/linux/sys/pidfd.h
--- a/sysdeps/unix/sysv/linux/sys/pidfd.h
+++ b/sysdeps/unix/sysv/linux/sys/pidfd.h
@@ -38,14 +38,6 @@ extern int pidfd_open (__pid_t __pid, un
 extern int pidfd_getfd (int __pidfd, int __targetfd,
 			unsigned int __flags) __THROW;
 
-/* Sends the signal SIG to the target process referred by the PIDFD.  If
-   INFO points to a siginfo_t buffer, it will be populated.
-
-   The FLAGS argument is reserved for future use, it must be specified
-   as 0.  */
-extern int pidfd_send_signal (int __pidfd, int __sig, siginfo_t *__info,
-			      unsigned int __flags) __THROW;
-
 /* Query the process ID (PID) from process descriptor FD.  Return the PID
    or -1 in case of an error.  */
 extern pid_t pidfd_getpid (int __fd) __THROW;
diff -Narupa a/sysdeps/unix/sysv/linux/syscall.c b/sysdeps/unix/sysv/linux/syscall.c
--- a/sysdeps/unix/sysv/linux/syscall.c
+++ b/sysdeps/unix/sysv/linux/syscall.c
@@ -1,29 +1,13 @@
-/* Indirect system call.  Linux generic implementation.
-   Copyright (C) 1997-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
 #include <stdarg.h>
 #include <sysdep.h>
+#include <fake-syscall.h>
+
+extern long int syscallS (long int __sysno, ...) __THROW;
 
 long int
 syscall (long int number, ...)
 {
   va_list args;
-
   va_start (args, number);
   long int a0 = va_arg (args, long int);
   long int a1 = va_arg (args, long int);
@@ -33,11 +17,8 @@ syscall (long int number, ...)
   long int a5 = va_arg (args, long int);
   va_end (args);
 
-  long int r = INTERNAL_SYSCALL_NCS_CALL (number, a0, a1, a2, a3, a4, a5);
-  if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r)))
-    {
-      __set_errno (-r);
-      return -1;
-    }
-  return r;
+  for (int i=0; i<CountFakeSyscalls; ++i)
+    if (FakeSyscalls[i].id == number)
+      return FakeSyscalls[i].func(a0, a1, a2, a3, a4, a5);
+  return syscallS (number, a0, a1, a2, a3, a4, a5);
 }
diff -Narupa a/sysdeps/unix/sysv/linux/tcsetattr.c b/sysdeps/unix/sysv/linux/tcsetattr.c
--- a/sysdeps/unix/sysv/linux/tcsetattr.c
+++ b/sysdeps/unix/sysv/linux/tcsetattr.c
@@ -55,7 +55,7 @@ __tcsetattr (int fd, int optional_action
       cmd = TCSETSW;
       break;
     case TCSAFLUSH:
-      cmd = TCSETSF;
+      cmd = TCSETS;
       break;
     default:
       return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
diff -Narupa a/sysdeps/unix/sysv/linux/tst-rseq-disable.c b/sysdeps/unix/sysv/linux/tst-rseq-disable.c
--- a/sysdeps/unix/sysv/linux/tst-rseq-disable.c
+++ b/sysdeps/unix/sysv/linux/tst-rseq-disable.c
@@ -39,20 +39,7 @@ check_rseq_disabled (void)
   TEST_COMPARE (__rseq_size, 0);
   TEST_COMPARE ((int) pd->rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
 
-  int ret = syscall (__NR_rseq, &pd->rseq_area, sizeof (pd->rseq_area),
-                     0, RSEQ_SIG);
-  if (ret == 0)
-    {
-      ret = syscall (__NR_rseq, &pd->rseq_area, sizeof (pd->rseq_area),
-                     RSEQ_FLAG_UNREGISTER, RSEQ_SIG);
-      TEST_COMPARE (ret, 0);
-      pd->rseq_area.cpu_id = RSEQ_CPU_ID_REGISTRATION_FAILED;
-    }
-  else
-    {
-      TEST_VERIFY (errno != -EINVAL);
-      TEST_VERIFY (errno != -EBUSY);
-    }
+  pd->rseq_area.cpu_id = RSEQ_CPU_ID_REGISTRATION_FAILED;
 }
 
 static void *
diff -Narupa a/sysdeps/unix/sysv/linux/tst-rseq.h b/sysdeps/unix/sysv/linux/tst-rseq.h
--- a/sysdeps/unix/sysv/linux/tst-rseq.h
+++ b/sysdeps/unix/sysv/linux/tst-rseq.h
@@ -30,20 +30,9 @@ rseq_thread_registered (void)
   return THREAD_GETMEM_VOLATILE (THREAD_SELF, rseq_area.cpu_id) >= 0;
 }
 
-static inline int
-sys_rseq (struct rseq *rseq_abi, uint32_t rseq_len, int flags, uint32_t sig)
-{
-  return syscall (__NR_rseq, rseq_abi, rseq_len, flags, sig);
-}
-
 static inline bool
 rseq_available (void)
 {
-  int rc;
-
-  rc = sys_rseq (NULL, 0, 0, 0);
-  if (rc != -1)
-    FAIL_EXIT1 ("Unexpected rseq return value %d", rc);
   switch (errno)
     {
     case ENOSYS:
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h b/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h
--- a/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h
@@ -1,6 +1,5 @@
 /* AUTOGENERATED by update-syscall-lists.py.  */
 #define __NR__sysctl 156
-#define __NR_accept 43
 #define __NR_accept4 288
 #define __NR_access 21
 #define __NR_acct 163
@@ -16,8 +15,6 @@
 #define __NR_capget 125
 #define __NR_capset 126
 #define __NR_chdir 80
-#define __NR_chmod 90
-#define __NR_chown 92
 #define __NR_chroot 161
 #define __NR_clock_adjtime 305
 #define __NR_clock_getres 229
@@ -25,9 +22,7 @@
 #define __NR_clock_nanosleep 230
 #define __NR_clock_settime 227
 #define __NR_clone 56
-#define __NR_clone3 435
 #define __NR_close 3
-#define __NR_close_range 436
 #define __NR_connect 42
 #define __NR_copy_file_range 326
 #define __NR_creat 85
@@ -41,7 +36,6 @@
 #define __NR_epoll_ctl 233
 #define __NR_epoll_ctl_old 214
 #define __NR_epoll_pwait 281
-#define __NR_epoll_pwait2 441
 #define __NR_epoll_wait 232
 #define __NR_epoll_wait_old 215
 #define __NR_eventfd 284
@@ -51,7 +45,6 @@
 #define __NR_exit 60
 #define __NR_exit_group 231
 #define __NR_faccessat 269
-#define __NR_faccessat2 439
 #define __NR_fadvise64 221
 #define __NR_fallocate 285
 #define __NR_fanotify_init 300
@@ -59,7 +52,6 @@
 #define __NR_fchdir 81
 #define __NR_fchmod 91
 #define __NR_fchmodat 268
-#define __NR_fchmodat2 452
 #define __NR_fchown 93
 #define __NR_fchownat 260
 #define __NR_fcntl 72
@@ -82,7 +74,6 @@
 #define __NR_futex 202
 #define __NR_futex_requeue 456
 #define __NR_futex_wait 455
-#define __NR_futex_waitv 449
 #define __NR_futex_wake 454
 #define __NR_futimesat 261
 #define __NR_get_kernel_syms 177
@@ -100,7 +91,6 @@
 #define __NR_getitimer 36
 #define __NR_getpeername 52
 #define __NR_getpgid 121
-#define __NR_getpgrp 111
 #define __NR_getpid 39
 #define __NR_getpmsg 181
 #define __NR_getppid 110
@@ -142,7 +132,6 @@
 #define __NR_keyctl 250
 #define __NR_kill 62
 #define __NR_landlock_add_rule 445
-#define __NR_landlock_create_ruleset 444
 #define __NR_landlock_restrict_self 446
 #define __NR_lchown 94
 #define __NR_lgetxattr 192
@@ -207,7 +196,6 @@
 #define __NR_personality 135
 #define __NR_pidfd_getfd 438
 #define __NR_pidfd_open 434
-#define __NR_pidfd_send_signal 424
 #define __NR_pipe 22
 #define __NR_pipe2 293
 #define __NR_pivot_root 155
@@ -250,8 +238,6 @@
 #define __NR_renameat2 316
 #define __NR_request_key 249
 #define __NR_restart_syscall 219
-#define __NR_rmdir 84
-#define __NR_rseq 334
 #define __NR_rt_sigaction 13
 #define __NR_rt_sigpending 127
 #define __NR_rt_sigprocmask 14
@@ -285,13 +271,9 @@
 #define __NR_sendto 44
 #define __NR_set_mempolicy 238
 #define __NR_set_mempolicy_home_node 450
-#define __NR_set_robust_list 273
 #define __NR_set_thread_area 205
 #define __NR_set_tid_address 218
 #define __NR_setdomainname 171
-#define __NR_setfsgid 123
-#define __NR_setfsuid 122
-#define __NR_setgid 106
 #define __NR_setgroups 116
 #define __NR_sethostname 170
 #define __NR_setitimer 38
@@ -299,14 +281,12 @@
 #define __NR_setpgid 109
 #define __NR_setpriority 141
 #define __NR_setregid 114
-#define __NR_setresgid 119
 #define __NR_setresuid 117
 #define __NR_setreuid 113
 #define __NR_setrlimit 160
 #define __NR_setsid 112
 #define __NR_setsockopt 54
 #define __NR_settimeofday 164
-#define __NR_setuid 105
 #define __NR_setxattr 188
 #define __NR_shmat 30
 #define __NR_shmctl 31
@@ -321,10 +301,8 @@
 #define __NR_splice 275
 #define __NR_stat 4
 #define __NR_statfs 137
-#define __NR_statx 332
 #define __NR_swapoff 168
 #define __NR_swapon 167
-#define __NR_symlink 88
 #define __NR_symlinkat 266
 #define __NR_sync 162
 #define __NR_sync_file_range 277
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/64/disabled-syscall.h b/sysdeps/unix/sysv/linux/x86_64/64/disabled-syscall.h
--- a/sysdeps/unix/sysv/linux/x86_64/64/disabled-syscall.h
+++ b/sysdeps/unix/sysv/linux/x86_64/64/disabled-syscall.h
@@ -0,0 +1,22 @@
+#define __NR_accept 43
+#define __NR_chmod 90
+#define __NR_chown 92
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_epoll_pwait2 441
+#define __NR_faccessat2 439
+#define __NR_fchmodat2 452
+#define __NR_futex_waitv 449
+#define __NR_getpgrp 111
+#define __NR_landlock_create_ruleset 444
+#define __NR_pidfd_send_signal 424
+#define __NR_rmdir 84
+#define __NR_rseq 334
+#define __NR_set_robust_list 273
+#define __NR_setfsgid 123
+#define __NR_setfsuid 122
+#define __NR_setgid 106
+#define __NR_setresgid 119
+#define __NR_setuid 105
+#define __NR_statx 332
+#define __NR_symlink 88
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/clone3.S b/sysdeps/unix/sysv/linux/x86_64/clone3.S
--- a/sysdeps/unix/sysv/linux/x86_64/clone3.S
+++ b/sysdeps/unix/sysv/linux/x86_64/clone3.S
@@ -1,89 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/x86-64 version.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* clone3() is even more special than fork() as it mucks with stacks
-   and invokes a function in the right context after its all over.  */
-
-#include <sysdep.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-	       int (*func)(void *arg), void *arg);
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   rdi: cl_args
-   rsi: size
-   rdx: func
-   rcx: arg
-
-   The kernel expects:
-   rax: system call number
-   rdi: cl_args
-   rsi: size  */
-
-        .text
-ENTRY (__clone3)
-	/* Sanity check arguments.  */
-	movl	$-EINVAL, %eax
-	test	%RDI_LP, %RDI_LP	/* No NULL cl_args pointer.  */
-	jz	SYSCALL_ERROR_LABEL
-	test	%RDX_LP, %RDX_LP	/* No NULL function pointer.  */
-	jz	SYSCALL_ERROR_LABEL
-
-	/* Save the cl_args pointer in R8 which is preserved by the
-	   syscall.  */
-	mov	%RCX_LP, %R8_LP
-
-	/* Do the system call.  */
-	movl	$SYS_ify(clone3), %eax
-
-	/* End FDE now, because in the child the unwind info will be
-	   wrong.  */
-	cfi_endproc
-	syscall
-
-	test	%RAX_LP, %RAX_LP
-	jl	SYSCALL_ERROR_LABEL
-	jz	L(thread_start)
-
-	ret
-
-L(thread_start):
-	cfi_startproc
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (rip)
-	/* Clear the frame pointer.  The ABI suggests this be done, to mark
-	   the outermost frame obviously.  */
-	xorl	%ebp, %ebp
-
-	/* Set up arguments for the function call.  */
-	mov	%R8_LP, %RDI_LP	/* Argument.  */
-	call	*%rdx		/* Call function.  */
-	/* Call exit with return value from function call. */
-	movq	%rax, %rdi
-	movl	$SYS_ify(exit), %eax
-	syscall
-	cfi_endproc
-
-	cfi_startproc
-PSEUDO_END (__clone3)
-
-libc_hidden_def (__clone3)
-weak_alias (__clone3, clone3)
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/configure b/sysdeps/unix/sysv/linux/x86_64/configure
--- a/sysdeps/unix/sysv/linux/x86_64/configure
+++ b/sysdeps/unix/sysv/linux/x86_64/configure
@@ -1,5 +0,0 @@
-# This file is generated from configure.ac by Autoconf.  DO NOT EDIT!
- # Local configure fragment for sysdeps/unix/sysv/linux/x86_64.
-
-ldd_rewrite_script=sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
-
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/configure.ac b/sysdeps/unix/sysv/linux/x86_64/configure.ac
--- a/sysdeps/unix/sysv/linux/x86_64/configure.ac
+++ b/sysdeps/unix/sysv/linux/x86_64/configure.ac
@@ -1,4 +0,0 @@
-GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
-# Local configure fragment for sysdeps/unix/sysv/linux/x86_64.
-
-ldd_rewrite_script=sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
diff -Narupa a/sysdeps/unix/sysv/linux/x86_64/syscall.S b/sysdeps/unix/sysv/linux/x86_64/syscall.S
--- a/sysdeps/unix/sysv/linux/x86_64/syscall.S
+++ b/sysdeps/unix/sysv/linux/x86_64/syscall.S
@@ -26,7 +26,7 @@
 
 
 	.text
-ENTRY (syscall)
+ENTRY (syscallS)
 	movq %rdi, %rax		/* Syscall number -> rax.  */
 	movq %rsi, %rdi		/* shift arg1 - arg5.  */
 	movq %rdx, %rsi
@@ -39,4 +39,4 @@ ENTRY (syscall)
 	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 	ret			/* Return to caller.  */
 
-PSEUDO_END (syscall)
+PSEUDO_END (syscallS)
diff -Narupa a/sysdeps/unix/sysv/linux/xstat64.c b/sysdeps/unix/sysv/linux/xstat64.c
--- a/sysdeps/unix/sysv/linux/xstat64.c
+++ b/sysdeps/unix/sysv/linux/xstat64.c
@@ -52,17 +52,6 @@ ___xstat64 (int vers, const char *name,
   /* New kABIs which uses generic 64-bit Linux ABI, e.g. aarch64, riscv64.  */
   if (vers == _STAT_VER_KERNEL)
     return INLINE_SYSCALL_CALL (newfstatat, AT_FDCWD, name, buf, 0);
-# else
-  /* New 32-bit kABIs with only 64-bit time_t support, e.g. arc, riscv32.  */
-  if (vers == _STAT_VER_KERNEL)
-    {
-      struct statx tmp;
-      int r = INLINE_SYSCALL_CALL (statx, AT_FDCWD, name, AT_NO_AUTOMOUNT,
-				   STATX_BASIC_STATS, &tmp);
-      if (r == 0)
-	__cp_stat64_statx (buf, &tmp);
-      return r;
-     }
 # endif
 #else
 # if STAT_IS_KERNEL_STAT
diff -Narupa a/timezone/tzfile.h b/timezone/tzfile.h
--- a/timezone/tzfile.h
+++ b/timezone/tzfile.h
@@ -22,11 +22,11 @@
 */
 
 #ifndef TZDIR
-#define TZDIR	"/usr/share/zoneinfo" /* Time zone object file directory */
+#define TZDIR	"/system/usr/share/zoneinfo" /* Time zone object file directory */
 #endif /* !defined TZDIR */
 
 #ifndef TZDEFAULT
-#define TZDEFAULT	"/etc/localtime"
+#define TZDEFAULT	"/data/data/com.termux/files/usr/etc/localtime"
 #endif /* !defined TZDEFAULT */
 
 #ifndef TZDEFRULES
